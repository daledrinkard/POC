<?xml version="1.0" ?>
<raModuleDescription>
    <config id="config.driver.usb_basic" path="fsp_cfg/r_usb_basic_cfg.h" version="0">
        <property id="config.driver.usb_basic.param_checking_enable" display="Parameter Checking" default="config.driver.usb_basic.param_checking_enable.bsp" description="If selected code for parameter checking is included in the build.">
            <option id="config.driver.usb_basic.param_checking_enable.bsp" display="Default (BSP)" value="BSP_CFG_PARAM_CHECKING_ENABLE" />
            <option id="config.driver.usb_basic.param_checking_enable.enabled" display="Enabled" value="(1)" />
            <option id="config.driver.usb_basic.param_checking_enable.disabled" display="Disabled" value="(0)" />
        </property>
        <property id="config.driver.usb_basic.pll_clock_frequency" display="PLL Frequency" default="" description="Specify the PLL frequency supplied to the USB module. This setting only applies to USB1 (not USB0).">
            <select enum = "enum.mcu.usb_basic.pll_clock_frequency" />
        </property>
        <property id="config.driver.usb_basic.buswait" display="CPU Bus Access Wait Cycles" default="" description="This setting controls the delay for consecutive USB peripheral register access. Set this value to a number of CPU cycles that is equivalent to 40.8ns or more.">
            <select enum = "enum.mcu.usb_basic.buswait" />
        </property>
        <property id="config.driver.usb_basic.bc_function" display="Battery Charging" default="" description="Specify whether or not to include battery charging functionality.">
            <select enum = "enum.mcu.usb_basic.bc_function" />
        </property>
        <property id="config.driver.usb_basic.power_source" display="Power IC Shutdown Polarity" default="" description="Select the polarity of the Shutdown signal on the power supply IC (if provided).">
            <select enum = "enum.mcu.usb_basic.power_source" />
        </property>
        <property id="config.driver.usb_basic.dcp_function" display="Dedicated Charging Port (DCP) Mode" default="" description="When enabled, USB communication is disabled and the port is used for charging only.">
            <select enum = "enum.mcu.usb_basic.dcp_function" />
        </property>
        <property id="config.driver.usb_basic.request" display="Notifications for SET_INTERFACE/SET_FEATURE/CLEAR_FEATURE" default="config.driver.usb_basic.request.enable" description="When enabled, the application will receive notifications for SET_INTERFACE, SET_FEATURE and CLEAR_FEATURE messages.">
            <option id="config.driver.usb_basic.request.disable" display="Disabled" value="USB_CFG_DISABLE"/>
            <option id="config.driver.usb_basic.request.enable" display="Enabled" value="USB_CFG_ENABLE"/>
        </property>
        <property id="config.driver.usb_basic.dblb" display="Double Buffering" default="config.driver.usb_basic.dblb.enable" description="When enabled, the FIFOs for Pipes 1-5 are double-buffered.">
            <option id="config.driver.usb_basic.dblb.disable" display="Disabled" value="USB_CFG_DBLBOFF"/>
            <option id="config.driver.usb_basic.dblb.enable" display="Enabled" value="USB_CFG_DBLBON"/>
        </property>
        <property id="config.driver.usb_basic.cntmd" display="Continuous Transfer Mode" default="" description="Enable or disable continuous transfer mode.">
            <select enum = "enum.mcu.usb_basic.cntmd" />
        </property>
        <property id="config.driver.usb_basic.ldo_regulator" display="LDO Regulator" default="" description="Enable or disable LDO regulator.">
            <select enum = "enum.mcu.usb_basic.ldo_regulator" />
        </property>
        <property id="config.driver.usb_basic.dma" display="DMA Support" default="" description="Enable or disable DMA support for the USB module.">
            <select enum = "enum.mcu.usb_basic.dma" />
        </property>
        <property id="config.driver.usb_basic.source_address" display="DMA Source Address" default="" description="Set this to match the speed mode when DMA is enabled. Otherwise, set to 'DMA Disabled'.">
            <select enum = "enum.mcu.usb_basic.source_address" />
        </property>
        <property id="config.driver.usb_basic.dest_address" display="DMA Destination Address" default="" description="Set this to match the speed mode when DMA is enabled. Otherwise, set to 'DMA Disabled'.">
            <select enum = "enum.mcu.usb_basic.dest_address" />
        </property>
        <property id="config.driver.usb_basic.compliance_mode" display="USB Compliance Test mode" default="config.driver.usb_basic.compliance_mode.disable" description="Display the information required to take the compliance test. ">
            <option id="config.driver.usb_basic.compliance_mode.enable" display="Enabled" value="USB_CFG_ENABLE"/>
            <option id="config.driver.usb_basic.compliance_mode.disable" display="Disabled" value="USB_CFG_DISABLE"/>
        </property>
        <property id="config.driver.usb_basic.tpl_table" display="USB TPL table name" default="NULL" description="Enter the name of the TPL Table. ">
            <constraint display="Enter the TPL table name.">testSymbol("${config.driver.usb_basic.tpl_table}")</constraint>
        </property>
        <content>
            #ifdef __cplusplus
            extern "C" {
            #endif

            #ifndef ${config.driver.usb_basic.tpl_table}
            extern const uint16_t ${config.driver.usb_basic.tpl_table}[];
            #endif

            #if (${interface.driver.hcdc} != RA_NOT_DEFINED)
            #define USB_CFG_HCDC_USE
            #endif
            #if (${interface.driver.hhid} != RA_NOT_DEFINED)
            #define USB_CFG_HHID_USE
            #endif
            #if (${interface.driver.hmsc} != RA_NOT_DEFINED)
            #define USB_CFG_HMSC_USE
            #endif
            #if (${interface.driver.hvnd} != RA_NOT_DEFINED)
            #define USB_CFG_HVND_USE
            #endif
            #if (${interface.driver.hprn} != RA_NOT_DEFINED)
            #define USB_CFG_HPRN_USE
            #endif
            #if ((${interface.driver.pcdc} != RA_NOT_DEFINED) || (${interface.driver.rm_comms_on_usb_pcdc} != RA_NOT_DEFINED))
            #define USB_CFG_PCDC_USE
            #endif
            #if (${interface.driver.phid} != RA_NOT_DEFINED)
            #define USB_CFG_PHID_USE
            #endif
            #if (${interface.driver.pmsc} != RA_NOT_DEFINED)
            #define USB_CFG_PMSC_USE
            #endif
            #if (${interface.driver.pprn} != RA_NOT_DEFINED)
            #define USB_CFG_PPRN_USE
            #endif
            #if (${interface.driver.pvnd} != RA_NOT_DEFINED)
            #define USB_CFG_PVND_USE
            #endif
            #if (${interface.driver.usbx_hcdc} != RA_NOT_DEFINED)
            #define USB_CFG_HCDC_USE
            #endif
            #if (${interface.driver.usbx_hmsc} != RA_NOT_DEFINED)
            #define USB_CFG_HMSC_USE
            #endif
            #if (${interface.driver.usbx_hhid} != RA_NOT_DEFINED)
            #define USB_CFG_HHID_USE
            #endif
            #if (${interface.driver.usbx_hprn} != RA_NOT_DEFINED)
            #define USB_CFG_HPRN_USE
            #endif
            #if (${interface.driver.usbx_huvc} != RA_NOT_DEFINED)
            #define USB_CFG_HUVC_USE
            #endif
            #if (${interface.driver.usbx_pcdc} != RA_NOT_DEFINED)
            #define USB_CFG_PCDC_USE
            #endif
            #if (${interface.driver.usbx_pprn} != RA_NOT_DEFINED)
            #define USB_CFG_PPRN_USE
            #endif
            #if (${interface.driver.usbx_phid} != RA_NOT_DEFINED)
            #define USB_CFG_PHID_USE
            #endif
            #if (${interface.driver.usbx_pmsc} != RA_NOT_DEFINED)
            #define USB_CFG_PMSC_USE
            #endif
            #if (${interface.driver.usbx_paud} != RA_NOT_DEFINED)
            #define USB_CFG_PAUD_USE
            #endif
            #if (${interface.driver.usbx_dfu} != RA_NOT_DEFINED)
            #define USB_CFG_DFU_USE
            #endif
            #if ((${interface.driver.usbx_otg_cdc} != RA_NOT_DEFINED) || (${interface.driver.usbx_otg_hid} != RA_NOT_DEFINED) || (${interface.driver.usbx_otg_msc} != RA_NOT_DEFINED))
            #define USB_CFG_OTG_USE
            #endif
            #if (defined(USB_CFG_HCDC_USE) || defined(USB_CFG_HPRN_USE) || defined(USB_CFG_HMSC_USE) || defined(USB_CFG_HHID_USE) || defined(USB_CFG_HVND_USE) || defined(USB_CFG_HUVC_USE))
            #define USB_CFG_HOST_MODE 1
            #else
            #define USB_CFG_HOST_MODE 0
            #endif

            #if (defined(USB_CFG_PCDC_USE) || defined(USB_CFG_PPRN_USE) || defined(USB_CFG_PMSC_USE) || defined(USB_CFG_PHID_USE) || defined(USB_CFG_PVND_USE) || defined(USB_CFG_PAUD_USE) || defined(USB_CFG_DFU_USE))
            #define USB_CFG_PERI_MODE 2
            #else
            #define USB_CFG_PERI_MODE 0
            #endif

            #define USB_CFG_MODE (USB_CFG_PERI_MODE | USB_CFG_HOST_MODE)

            #define USB_CFG_PARAM_CHECKING_ENABLE (${config.driver.usb_basic.param_checking_enable})
            #define USB_CFG_CLKSEL (${config.driver.usb_basic.pll_clock_frequency})
            #define USB_CFG_BUSWAIT (${config.driver.usb_basic.buswait})
            #define USB_CFG_BC (${config.driver.usb_basic.bc_function})
            #define USB_CFG_VBUS (${config.driver.usb_basic.power_source})
            #define USB_CFG_DCP (${config.driver.usb_basic.dcp_function})
            #define USB_CFG_CLASS_REQUEST (${config.driver.usb_basic.request})
            #define USB_CFG_DBLB (${config.driver.usb_basic.dblb})
            #define USB_CFG_CNTMD (${config.driver.usb_basic.cntmd})
            #define USB_CFG_LDO_REGULATOR (${config.driver.usb_basic.ldo_regulator})
            #define USB_CFG_DMA   (${config.driver.usb_basic.dma})
            #define USB_SRC_ADDRESS (${config.driver.usb_basic.source_address})
            #define USB_DEST_ADDRESS (${config.driver.usb_basic.dest_address})
            #define USB_CFG_TPLCNT (1)
            #define USB_CFG_TPL USB_NOVENDOR, USB_NOPRODUCT
            #define USB_CFG_TPL_TABLE ${config.driver.usb_basic.tpl_table}
            #define USB_CFG_COMPLIANCE (${config.driver.usb_basic.compliance_mode})

            #ifdef __cplusplus
            }
            #endif
        </content>
    </config>
    <module config="config.driver.usb_basic" display="Connectivity|${module.driver.basic.name} USB (r_usb_basic)" id="module.driver.basic_on_usb_nodmac" visible="false" version="0" url="group___u_s_b.html">
        <constraint display="Unique name required for each instance">
          "${interface.driver.basic.${module.driver.basic.name}}" === "1"
        </constraint>
        <constraint display="Requires USB Peripheral">
          "${interface.mcu.usb_fs.external}" === "1"
        </constraint>
        <constraint display="Requires USB clock to be 48 MHz">
          testExists("${board.clock.peripheral.usb}") &amp;&amp; (Number("${board.clock.peripheral.usb}") == 48000000)
        </constraint>
        <constraint display="This MCU does not support Host.">
          "${module.driver.usb_basic.usb_mode}" === "module.driver.usb_basic.usb_mode.peri"
        </constraint>
        <constraint display="This MCU does not support Hi-Speed.">
          !("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs")
        </constraint>
        <constraint display="USB_IP1 does not exist in this MCU.">
          "${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0"
        </constraint>
        <constraint display="This MCU does not support DMA.">
          "${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.disable"
        </constraint>
        <constraint display="This MCU does not support DMA.">
          "${config.driver.usb_basic.source_address}" === "config.driver.usb_basic.source_address.none"
        </constraint>
        <constraint display="This MCU does not support DMA.">
          "${config.driver.usb_basic.dest_address}" === "config.driver.usb_basic.dest_address.none"
        </constraint>
        <constraint display="&quot;Support Dynamic Allocation&quot; must be Enabled in FreeRTOS Thread &quot;setting|Common|Memory Allocation&quot;.">
          "${config.awsfreertos.thread.configsupport_dynamic_allocation}" === "config.awsfreertos.thread.configsupport_dynamic_allocation.enabled" ||
            "1" != "${interface.rtos.awsfreertos}"
        </constraint>
        <constraint display="The PCDC does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.pcdc"))
        </constraint>
        <constraint display="Continuous transfer mode does not support on USB IP0 port.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${config.driver.usb_basic.cntmd}" === "config.driver.usb_basic.cntmd.enable"))
        </constraint>
        <constraint display="The USBFS Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBFS Resume Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl_r}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl_r}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="Specify USBFS Interrupt Priority.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.usb_basic.ipl}" === "_disabled"))
        </constraint>
        <requires id="module.driver.basic_on_usb.requires.basic" interface="interface.mcu.usb_fs.external" visible="false" display="Requires USB Peripheral" />
        <!-- Will need to update this if other MCUs are released that have USB but not DMAC -->
        <requires id="module.driver.basic_on_usb.requires.no_dmac" interface="interface.mcu.usb.pipes.0.4.5.6.7" visible="false" display="Requires MCU without DMAC peripheral" />
        <provides interface="interface.driver.basic.${module.driver.basic.name}" />
        <provides interface="interface.driver.basic" />
        <provides interface="interface.driver.basic_on_usb" />
        <provides interface="interface.peripheral.usbfs" />
        <property default="basic" id="module.driver.basic.basic_interface" description=""/>
        <property default="g_basic${_instance}" display="Name" id="module.driver.basic.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.driver.basic.name}")</constraint>
        </property>
        <property display="USB Mode" id="module.driver.usb_basic.usb_mode" default="module.driver.usb_basic.usb_mode.peri" description="Select the usb mode.">
            <option id="module.driver.usb_basic.usb_mode.host" display="Host mode" value="USB_MODE_HOST" />
            <option id="module.driver.usb_basic.usb_mode.peri" display="Peri mode" value="USB_MODE_PERI" />
        </property>
        <property display="USB Speed" id="module.driver.usb_basic.usb_speed" default="module.driver.usb_basic.usb_speed.fs" description="Select the USB speed.">
            <option id="module.driver.usb_basic.usb_speed.fs" display="Full Speed" value="USB_SPEED_FS" />
            <option id="module.driver.usb_basic.usb_speed.hs" display="Hi Speed" value="USB_SPEED_HS" />
            <option id="module.driver.usb_basic.usb_speed.ls" display="Low Speed" value="USB_SPEED_LS" />
        </property>
        <property display="USB Module Number" id="module.driver.usb_basic.usb_modulenumber" default="module.driver.usb_basic.usb_modulenumber.0" description="Specify the USB module number to be used.">
            <option id="module.driver.usb_basic.usb_modulenumber.0" display="USB_IP0 Port" value="0" />
            <option id="module.driver.usb_basic.usb_modulenumber.1" display="USB_IP1 Port" value="1" />
        </property>
        <property display="USB Device Class" id="module.driver.usb_basic.usb_classtype" default="module.driver.usb_basic.usb_classtype.pcdc" description="Select the USB device class.">
            <option id="module.driver.usb_basic.usb_classtype.pcdc" display="Peripheral Communications Device Class" value="USB_CLASS_PCDC" />
            <option id="module.driver.usb_basic.usb_classtype.phid" display="Peripheral Human Interface Device Class" value="USB_CLASS_PHID" />
            <option id="module.driver.usb_basic.usb_classtype.pmsc" display="Peripheral Mass Storage Class" value="USB_CLASS_PMSC" />
            <option id="module.driver.usb_basic.usb_classtype.pvnd" display="Peripheral Vendor Class" value="USB_CLASS_PVND" />
            <option id="module.driver.usb_basic.usb_classtype.paud" display="Peripheral Audio Class" value="USB_CLASS_PAUD" />
            <option id="module.driver.usb_basic.usb_classtype.pprn" display="Peripheral Printer Class" value="USB_CLASS_PPRN" />
            <option id="module.driver.usb_basic.usb_classtype.hcdc" display="Host Communications Device Class" value="USB_CLASS_HCDC" />
            <option id="module.driver.usb_basic.usb_classtype.hhid" display="Host Human Interface Device Class" value="USB_CLASS_HHID" />
            <option id="module.driver.usb_basic.usb_classtype.hmsc" display="Host Mass Storage Class" value="USB_CLASS_HMSC" />
            <option id="module.driver.usb_basic.usb_classtype.hvnd" display="Host Vendor Class" value="USB_CLASS_HVND" />
            <option id="module.driver.usb_basic.usb_classtype.hprn" display="Host Printer Class" value="USB_CLASS_HPRN" />
            <option id="module.driver.usb_basic.usb_classtype.huvc" display="Host Video Class" value="USB_CLASS_HUVC" />
            <option id="module.driver.usb_basic.usb_classtype.dfu" display="DFU Class" value="USB_CLASS_DFU" />
        </property>
        <property display="USB Descriptor" id="module.driver.usb_basic.p_usb_reg" default="g_usb_descriptor" description="Enter the name of the descriptor to be used.\nFor how to create a descriptor structure, refer to the Descriptor definition chapter in the usb_basic manual.\nSpecify NULL when using the Host class.">
            <constraint display="USB Descriptor must be a valid C symbol.">testSymbol("${module.driver.usb_basic.p_usb_reg}")</constraint>
        </property>
        <property display="USB Compliance Callback" id="module.driver.usb_basic.complience_cb" default="NULL" description="Set the callback for compliance tests here.">
            <constraint display="Compliance Callback must be a valid C symbol.">testSymbol("${module.driver.usb_basic.complience_cb}")</constraint>
        </property>
        <property display="USBFS Interrupt Priority" id="module.driver.usb_basic.ipl" default="" description="Select the interrupt priority used by the main USBFS ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.int" isr="usbfs_interrupt_handler"/>
        </property>
        <property display="USBFS Resume Priority" id="module.driver.usb_basic.ipl_r" default="" description="Select the interrupt priority used by the USBFS Resume ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.resume" isr="usbfs_resume_handler"/>
        </property>
        <property display="USB Callback" id="module.driver.usb_basic.rtos_callback" default="NULL" description="A user callback function can be defined here.">
            <constraint display="Enter the address of the function.">testSymbol("${module.driver.usb_basic.rtos_callback}")</constraint>
        </property>
        <property display="USB Callback Context" id="module.driver.usb_basic.other_context" default="NULL" description="Set the callback context here.">
            <constraint display="Enter the address of the context.">testSymbol("${module.driver.usb_basic.other_context}")</constraint>
        </property>
	<!-- List USB pins for MCU pinmappings that are generated with old MCU Utilities database -->
	<peripheral name="USB_FS" component="usbfs0" />
        <peripheral name="USB_HS" component="usbhs0" />		
	<!-- List USB pins for MCU pinmappings that are generated new MPC Designer tool -->
	<peripheral name="USB FS" component="usbfs" />
        <peripheral name="USB HS" component="usbhs" />

        <!-- symbol id -->
        <symbol id="symbol.driver.basic.name" value="${module.driver.basic.name}"/>
        <symbol id="symbol.driver.basic.guard.open" value="${module.driver.basic.name}_open_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.open" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Open"/>
        <symbol id="symbol.driver.basic.guard.close" value="${module.driver.basic.name}_close_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.close" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Close"/>
        <symbol id="symbol.driver.basic.guard.read" value="${module.driver.basic.name}_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Read"/>
        <symbol id="symbol.driver.basic.guard.write" value="${module.driver.basic.name}_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Write"/>
        <symbol id="symbol.driver.basic.guard.stop" value="${module.driver.basic.name}_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Stop"/>
        <symbol id="symbol.driver.basic.guard.suspend" value="${module.driver.basic.name}_suspend_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.suspend" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend"/>
        <symbol id="symbol.driver.basic.guard.resume" value="${module.driver.basic.name}_resume_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.resume" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Resume"/>
        <symbol id="symbol.driver.basic.guard.vbus_set" value="${module.driver.basic.name}_vbus_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.vbus_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet"/>
        <symbol id="symbol.driver.basic.guard.info_get" value="${module.driver.basic.name}_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_read" value="${module.driver.basic.name}_pipe_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead"/>
        <symbol id="symbol.driver.basic.guard.pipe_write" value="${module.driver.basic.name}_pipe_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite"/>
        <symbol id="symbol.driver.basic.guard.pipe_stop" value="${module.driver.basic.name}_pipe_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop"/>
        <symbol id="symbol.driver.basic.guard.used_pipes_get" value="${module.driver.basic.name}_used_pipes_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.used_pipes_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_info_get" value="${module.driver.basic.name}_pipe_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet"/>
        <symbol id="symbol.driver.basic.guard.pull_up" value="${module.driver.basic.name}_pull_up_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pull_up" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp"/>
        <symbol id="symbol.driver.basic.guard.event_get" value="${module.driver.basic.name}_event_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.event_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet"/>
        <symbol id="symbol.driver.basic.guard.callback" value="${module.driver.basic.name}_callback_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Callback"/>
        <symbol id="symbol.driver.basic.guard.host_control_transfer" value="${module.driver.basic.name}_host_control_transfer_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.host_control_transfer" value="FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_get" value="${module.driver.basic.name}_peri_control_data_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_set" value="${module.driver.basic.name}_peri_control_data_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_status_set" value="${module.driver.basic.name}_peri_control_status_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_status_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet"/>
        <symbol id="symbol.driver.basic.guard.remote_wakeup" value="${module.driver.basic.name}_remote_wakeup_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.remote_wakeup" value="FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup"/>
        <symbol id="symbol.driver.basic.guard.module_number_get" value="${module.driver.basic.name}_module_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.module_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet"/>
        <symbol id="symbol.driver.basic.guard.class_type_get" value="${module.driver.basic.name}_class_type_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.class_type_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet"/>
        <symbol id="symbol.driver.basic.guard.device_address_get" value="${module.driver.basic.name}_device_address_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_address_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_number_get" value="${module.driver.basic.name}_pipe_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet"/>
        <symbol id="symbol.driver.basic.guard.device_state_get" value="${module.driver.basic.name}_device_state_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_state_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet"/>
        <symbol id="symbol.driver.basic.guard.data_size_get" value="${module.driver.basic.name}_data_size_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.data_size_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet"/>
        <symbol id="symbol.driver.basic.guard.setup_get" value="${module.driver.basic.name}_setup_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.setup_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet"/>
        <symbol id="symbol.driver.basic.guard.driver_activate" value="${module.driver.basic.name}_driver_activate_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.driver_activate" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate"/>
        <symbol id="symbol.driver.basic.guard.callback_memory_set" value="${module.driver.basic.name}_callback_memory_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback_memory_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet"/>
        <symbol id="symbol.driver.basic.nsc_api" value="${module.driver.basic.name}_nsc_api"/>
        <symbol id="symbol.driver.basic.cfg" value="${module.driver.basic.name}_cfg"/>
        <symbol id="symbol.driver.basic.mac_address" value="${module.driver.basic.name}_mac_address"/>
        <symbol id="symbol.driver.basic.num_tx_descriptions" value="${module.driver.basic.name}_tx_descriptions"/>
        <symbol id="symbol.driver.basic.num_rx_descriptions" value="${module.driver.basic.name}_rx_descriptions"/>
        <symbol id="symbol.driver.basic.ctrl" value="${module.driver.basic.name}_ctrl"/>

        <header>

/* Basic on USB Instance. */
extern const usb_instance_t ${module.driver.basic.name};

/** Access the USB instance using these structures when calling API functions directly (::p_api is not used). */
extern usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;
extern const usb_cfg_t ${module.driver.basic.name}_cfg;

#ifndef ${module.driver.usb_basic.complience_cb}
void ${module.driver.usb_basic.complience_cb}(void *);
#endif

#if 2 == BSP_CFG_RTOS
#ifndef ${module.driver.usb_basic.rtos_callback}
void ${module.driver.usb_basic.rtos_callback}(usb_event_info_t *, usb_hdl_t, usb_onoff_t);
#endif
#endif
        </header>
        <includes>
#include &quot;r_usb_basic.h&quot;
#include &quot;r_usb_basic_api.h&quot;
        </includes>
        <declarations>

usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;

#if !defined(${module.driver.usb_basic.p_usb_reg})
extern usb_descriptor_t ${module.driver.usb_basic.p_usb_reg};
#endif
#define RA_NOT_DEFINED (1)
            const usb_cfg_t ${module.driver.basic.name}_cfg =
            {
                .usb_mode  = ${module.driver.usb_basic.usb_mode},
                .usb_speed = ${module.driver.usb_basic.usb_speed},
                .module_number = ${module.driver.usb_basic.usb_modulenumber},
                .type = ${module.driver.usb_basic.usb_classtype},
#if defined(${module.driver.usb_basic.p_usb_reg})
                .p_usb_reg = ${module.driver.usb_basic.p_usb_reg},
#else
                .p_usb_reg = &amp;${module.driver.usb_basic.p_usb_reg},
#endif
                .usb_complience_cb = ${module.driver.usb_basic.complience_cb},
#if defined(VECTOR_NUMBER_USBFS_INT)
                .irq       = VECTOR_NUMBER_USBFS_INT,
#else
                .irq       = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBFS_RESUME)
                .irq_r     = VECTOR_NUMBER_USBFS_RESUME,
#else
                .irq_r     = FSP_INVALID_VECTOR,
#endif
                .irq_d0    = FSP_INVALID_VECTOR,
                .irq_d1    = FSP_INVALID_VECTOR,
                .hsirq     = FSP_INVALID_VECTOR,
                .hsirq_d0  = FSP_INVALID_VECTOR,
                .hsirq_d1  = FSP_INVALID_VECTOR,
                .ipl       = ${module.driver.usb_basic.ipl},
                .ipl_r     = ${module.driver.usb_basic.ipl_r},
                .ipl_d0    = BSP_IRQ_DISABLED,
                .ipl_d1    = BSP_IRQ_DISABLED,
                .hsipl     = BSP_IRQ_DISABLED,
                .hsipl_d0  = BSP_IRQ_DISABLED,
                .hsipl_d1  = BSP_IRQ_DISABLED,
#if (BSP_CFG_RTOS == 0) &amp;&amp; defined(USB_CFG_HMSC_USE)
                .p_usb_apl_callback = NULL,
#else
                .p_usb_apl_callback = ${module.driver.usb_basic.rtos_callback},
#endif
#if defined(${module.driver.usb_basic.other_context})
                .p_context = ${module.driver.usb_basic.other_context},
#else
                .p_context = &amp;${module.driver.usb_basic.other_context},
#endif
            };
#undef RA_NOT_DEFINED

/* Instance structure to use this module. */
const usb_instance_t ${module.driver.basic.name} =
{
    .p_ctrl        = &amp;${module.driver.basic.name}_ctrl,
    .p_cfg         = &amp;${module.driver.basic.name}_cfg,
    .p_api         = &amp;g_usb_on_usb,
};
        </declarations>
        <guard>
            <header>

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);

            </header>
            <template name="${module.driver.basic.name}_guard.c">
                <![CDATA[
                    #include "guard.h"

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(cfg);

    return R_USB_Open(&${module.driver.basic.name}_ctrl, &${module.driver.basic.name}_cfg);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Close(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Read(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Write(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Stop(&${module.driver.basic.name}_ctrl, direction, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Suspend(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Resume(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_VbusSet(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    usb_info_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_InfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeRead(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeWrite(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeStop(&${module.driver.basic.name}_ctrl, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint16_t *const p_pipe_checked = cmse_check_pointed_object(p_pipe, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_pipe_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_UsedPipesGet(&${module.driver.basic.name}_ctrl, p_pipe_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    usb_pipe_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeInfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event)
{
    /* Verify all pointers are in non-secure memory. */
    usb_pipe_t *const p_event_checked = cmse_check_pointed_object(event, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_event_checked != NULL);

    /* TODO: add your own security checks here */

    return R_USB_EventGet(p_api_ctrl, event);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback)
{
    /* Verify all pointers are in non-secure memory. */
    usb_callback_t *const p_callback_checked = cmse_check_pointed_object(p_callback, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_checked != NULL);

    return R_USB_Callback(p_callback_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PullUp(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address)
{
    /* Verify all pointers are in non-secure memory. */
    usb_setup_t *const p_setup_checked = cmse_check_pointed_object(p_setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_setup_checked != NULL);
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, sizeof(uint8_t), CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_HostControlTransfer(&${module.driver.basic.name}_ctrl, p_setup_checked, p_buf_checked, device_address);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataGet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataSet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlStatusSet(&${module.driver.basic.name}_ctrl, status);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_RemoteWakeup(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * module_number_checked = cmse_check_pointed_object(module_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(module_number_checked != NULL);

    return R_USB_ModuleNumberGet(&${module.driver.basic.name}_ctrl, module_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_class_t * class_type_checked = cmse_check_pointed_object(class_type, CMSE_AU_NONSECURE);
    FSP_ASSERT(class_type_checked != NULL);

    return R_USB_ClassTypeGet(&${module.driver.basic.name}_ctrl, class_type_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * device_address_checked = cmse_check_pointed_object(device_address, CMSE_AU_NONSECURE);
    FSP_ASSERT(device_address_checked != NULL);

    return R_USB_DeviceAddressGet(&${module.driver.basic.name}_ctrl, device_address_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * pipe_number_checked = cmse_check_pointed_object(pipe_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(pipe_number_checked != NULL);

    return R_USB_PipeNumberGet(&${module.driver.basic.name}_ctrl, pipe_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint16_t * state_checked = cmse_check_pointed_object(state, CMSE_AU_NONSECURE);
    FSP_ASSERT(state_checked != NULL);

    return R_USB_DeviceStateGet(&${module.driver.basic.name}_ctrl, state_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint32_t * data_size_checked = cmse_check_pointed_object(data_size, CMSE_AU_NONSECURE);
    FSP_ASSERT(data_size_checked != NULL);

    return R_USB_DataSizeGet(&${module.driver.basic.name}_ctrl, data_size_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_setup_t * setup_checked = cmse_check_pointed_object(setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(setup_checked != NULL);

    return R_USB_SetupGet(&${module.driver.basic.name}_ctrl, setup_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_DriverActivate(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_callback_args_t * p_callback_memory_checked = cmse_check_pointed_object((void *)p_callback_memory, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_memory_checked != NULL);

    return R_USB_CallbackMemorySet(&${module.driver.basic.name}_ctrl, p_callback_memory_checked);
}

                ]]>
            </template>
        </guard>
        <nsc>
            <header>

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Open() ${module.driver.basic.name}_open_guard(FSP_SECURE_ARGUMENT, FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Close() ${module.driver.basic.name}_close_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Read(p_buf, size, destination) ${module.driver.basic.name}_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Write(p_buf, size, destination) ${module.driver.basic.name}_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Stop(direction, destination) ${module.driver.basic.name}_stop_guard(FSP_SECURE_ARGUMENT, direction, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend() ${module.driver.basic.name}_suspend_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Resume() ${module.driver.basic.name}_resume_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet(state) ${module.driver.basic.name}_vbus_set_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet(p_info, destination) ${module.driver.basic.name}_info_get_guard(FSP_SECURE_ARGUMENT, p_info, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop(pipe_number) ${module.driver.basic.name}_pipe_stop_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet(p_pipe, destination) ${module.driver.basic.name}_used_pipes_get_guard(FSP_SECURE_ARGUMENT, p_pipe, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet(p_info, pipe_number) ${module.driver.basic.name}_pipe_info_get_guard(FSP_SECURE_ARGUMENT, p_info, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet(p_api_ctrl, event) ${module.driver.basic.name}_event_get_guard(p_api_ctrl, event)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Callback(p_callback) ${module.driver.basic.name}_callback_guard(p_callback)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp(state) ${module.driver.basic.name}_pull_up_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer(p_setup, p_buf, device_address) ${module.driver.basic.name}_host_control_transfer_guard(FSP_SECURE_ARGUMENT, p_setup, p_buf, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet(p_buf, size) ${module.driver.basic.name}_peri_control_data_get_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet(p_buf, size) ${module.driver.basic.name}_peri_control_data_set_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet(status) ${module.driver.basic.name}_peri_control_status_set_guard(FSP_SECURE_ARGUMENT, status)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup() ${module.driver.basic.name}_remote_wakeup_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet(module_number) ${module.driver.basic.name}_module_number_get_guard(FSP_SECURE_ARGUMENT, module_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet(class_type) ${module.driver.basic.name}_class_type_get_guard(FSP_SECURE_ARGUMENT, class_type)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet(device_address) ${module.driver.basic.name}_device_address_get_guard(FSP_SECURE_ARGUMENT, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet(pipe_number) ${module.driver.basic.name}_pipe_number_get_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet(state) ${module.driver.basic.name}_device_state_get_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet(data_size) ${module.driver.basic.name}_data_size_get_guard(FSP_SECURE_ARGUMENT, data_size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet(setup) ${module.driver.basic.name}_setup_get_guard(FSP_SECURE_ARGUMENT, setup)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate() ${module.driver.basic.name}_driver_activate_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet(p_callback_memory) ${module.driver.basic.name}_callback_memory_set_guard(FSP_SECURE_ARGUMENT, p_callback_memory)


BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);

extern const usb_instance_t ${module.driver.basic.name};

            </header>
            <declarations>
                <![CDATA[

static const usb_api_t ${module.driver.basic.name}_nsc_api =
{
    .open                  = ${module.driver.basic.name}_open_guard,
    .close                 = ${module.driver.basic.name}_close_guard,
    .read                  = ${module.driver.basic.name}_read_guard,
    .write                 = ${module.driver.basic.name}_write_guard,
    .stop                  = ${module.driver.basic.name}_stop_guard,
    .suspend               = ${module.driver.basic.name}_suspend_guard,
    .resume                = ${module.driver.basic.name}_resume_guard,

    .vbusSet               = ${module.driver.basic.name}_vbus_set_guard,
    .infoGet               = ${module.driver.basic.name}_info_get_guard,
    .pipeRead              = ${module.driver.basic.name}_pipe_read_guard,
    .pipeWrite             = ${module.driver.basic.name}_pipe_write_guard,
    .pipeStop              = ${module.driver.basic.name}_pipe_stop_guard,
    .usedPipesGet          = ${module.driver.basic.name}_used_pipes_get_guard,
    .pullUp                = ${module.driver.basic.name}_pull_up_guard,
    .eventGet              = ${module.driver.basic.name}_event_get_guard,
    .callback              = ${module.driver.basic.name}_callback_guard,
    .hostControlTransfer   = ${module.driver.basic.name}_host_control_transfer_guard,
    .periControlDataGet    = ${module.driver.basic.name}_peri_control_data_get_guard,
    .periControlDataSet    = ${module.driver.basic.name}_peri_control_data_set_guard,
    .periControlStatusSet  = ${module.driver.basic.name}_peri_control_status_set_guard,

    .remoteWakeup          = ${module.driver.basic.name}_remote_wakeup_guard,
    .moduleNumberGet       = ${module.driver.basic.name}_module_number_get_guard,
    .classTypeGet          = ${module.driver.basic.name}_class_type_get_guard,
    .deviceAddressGet      = ${module.driver.basic.name}_device_address_get_guard,
    .pipeNumberGet         = ${module.driver.basic.name}_pipe_number_get_guard,
    .deviceStateGet        = ${module.driver.basic.name}_device_state_get_guard,
    .dataSizeGet           = ${module.driver.basic.name}_data_size_get_guard,
    .setupGet              = ${module.driver.basic.name}_setup_get_guard,
    .driverActivate        = ${module.driver.basic.name}_driver_activate_guard,
    .callbackMemorySet     = ${module.driver.basic.name}_callback_memory_set_guard,
};
const usb_instance_t ${module.driver.basic.name} =
{
    .p_api = &${module.driver.basic.name}_nsc_api,
    .p_ctrl = FSP_SECURE_ARGUMENT,
    .p_cfg = FSP_SECURE_ARGUMENT,
};


                ]]>
            </declarations>
        </nsc>
    </module>

    <module config="config.driver.usb_basic" display="Connectivity|${module.driver.basic.name} USB (r_usb_basic)" id="module.driver.basic_on_usb" visible="false" version="0" url="group___u_s_b.html">
        <constraint display="Unique name required for each instance">
          "${interface.driver.basic.${module.driver.basic.name}}" === "1"
        </constraint>
        <constraint display="Requires USB Peripheral">
          "${interface.mcu.usb_fs.external}" === "1"
        </constraint>
        <constraint display="Requires DMAC Peripheral">
          "${interface.mcu.dma_dmac}" === "1"
        </constraint>
        <constraint display="Set 48MHz to UCLK in Clocks tab when using USB IP0.">
          !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            (testExists("${board.clock.peripheral.usb}") &amp;&amp; (Number("${board.clock.peripheral.usb}") != 48000000)))
        </constraint>
        <constraint display="Set Full Speed when using CL only mode.">
          !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
            ("${config.driver.usb_basic.pll_clock_frequency}" === "config.driver.usb_basic.pll_clock_frequency.other"))
        </constraint>
        <constraint display="Set 48MHz to UCLK in Clocks tab when using CL only mode">
          !(("${config.driver.usb_basic.pll_clock_frequency}" === "config.driver.usb_basic.pll_clock_frequency.other") &amp;&amp;
            (testExists("${board.clock.peripheral.usb}") &amp;&amp; (Number("${board.clock.peripheral.usb}") != 48000000)))
        </constraint>
        <constraint display="USB_IP1 does not exist in this MCU.">
          ("${interface.mcu.usb_hs.external}" === "1") || ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0")
        </constraint>
        <constraint display="This MCU does not support Hi-Speed.">
          ("${interface.mcu.usb_hs.external}" === "1") || !("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs")
        </constraint>
        <constraint display="DMA support must be enabled to use DMA.">
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable") ||
            ((!testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")) &amp;&amp;
             (!testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When using DMA with HS, the module number must be USB_IP1 port.">
            (!(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${config.driver.usb_basic.source_address}" === "config.driver.usb_basic.source_address.hs_use")))
        </constraint>
        <constraint display="When using DMA with FS, the module number must be USB_IP0 port.">
            (!(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${config.driver.usb_basic.source_address}" === "config.driver.usb_basic.source_address.fs_use")))
        </constraint>
        <constraint display="When using DMA with HS, the module number must be USB_IP1 port.">
            (!(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${config.driver.usb_basic.dest_address}" === "config.driver.usb_basic.dest_address.hs_use")))
        </constraint>
        <constraint display="When using DMA with FS, the module number must be USB_IP0 port.">
            (!(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${config.driver.usb_basic.dest_address}" === "config.driver.usb_basic.dest_address.fs_use")))
        </constraint>
        <constraint display="&quot;DMA Source Address&quot; must be set to use DMA data reception.">
            !(("${config.driver.usb_basic.source_address}" === "config.driver.usb_basic.source_address.none") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="To use DMA data reception, add DMA module on the reception side.">
            !(!("${config.driver.usb_basic.source_address}" === "config.driver.usb_basic.source_address.none") &amp;&amp;
            (!testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="&quot;DMA Destination Address&quot; must be set to use DMA data transmission.">
            !(("${config.driver.usb_basic.dest_address}" === "config.driver.usb_basic.dest_address.none") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="To use DMA data transmission, add DMA module on the transmission side.">
            !(!("${config.driver.usb_basic.dest_address}" === "config.driver.usb_basic.dest_address.none") &amp;&amp;
            (!testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="Specify &quot;Not Supported&quot; in &quot;USBHS Interrupt Priority&quot; since this MCU does not support USB High-speed module.">
            !(("${interface.mcu.usb_hs.external}" !== "1") &amp;&amp; ("${module.driver.usb_basic.hsipl}" != "_disabled"))
        </constraint>
        <constraint display="Specify &quot;Not Supported&quot; in &quot;USBHS D0FIFO Interrupt Priority&quot; since this MCU does not support USB High-speed module.">
            !(("${interface.mcu.usb_hs.external}" !== "1") &amp;&amp; ("${module.driver.usb_basic.hsipl_d0}" != "_disabled"))
        </constraint>
        <constraint display="Specify &quot;Not Supported&quot; in &quot;USBHS D1FIFO Interrupt Priority&quot; since this MCU does not support USB High-speed module.">
            !(("${interface.mcu.usb_hs.external}" != "1") &amp;&amp; ("${module.driver.usb_basic.hsipl_d1}" != "_disabled"))
        </constraint>
        <constraint display="The HCDC does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.hcdc"))
        </constraint>
        <constraint display="The HPRN does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.hprn"))
        </constraint>
        <constraint display="The HMSC does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.hmsc"))
        </constraint>
        <constraint display="The PCDC does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.pcdc"))
        </constraint>
        <constraint display="The PPRN does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.pprn"))
        </constraint>
        <constraint display="The PMSC does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.pmsc"))
        </constraint>
        <constraint display="This driver does not support Hi-speed.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
              ("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
              (("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.phid") ||
               ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.dfu")) )
        </constraint>
        <constraint display="This driver does not support Full-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.fs") &amp;&amp;
              ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.huvc"))
        </constraint>
        <constraint display="USB_IP1 must be specified when using Hi-speed mode.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
            ("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
            ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0"))
        </constraint>
        <constraint display="The FreeRTOS Max Priorities configuration must be set greater than or equal to 4.">
            (4 &lt;= &quot;${config.awsfreertos.thread.configmax_priorities}&quot;) ||
             !testExists("${interface.rtos.awsfreertos}")
        </constraint>
        <constraint display="&quot;Support Dynamic Allocation&quot; must be &quot;Enabled&quot; in FreeRTOS Thread &quot;setting|Common|Memory Allocation&quot;.">
          "${config.awsfreertos.thread.configsupport_dynamic_allocation}" === "config.awsfreertos.thread.configsupport_dynamic_allocation.enabled" ||
            "1" != "${interface.rtos.awsfreertos}"
        </constraint>
        <constraint display="Continuous transfer mode cannot be used with DMA when operating in Host Mass Storage Class (HMSC) mode.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable") &amp;&amp;
            ("${config.driver.usb_basic.cntmd}" === "config.driver.usb_basic.cntmd.enable") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.hmsc"))
        </constraint>
        <constraint display="Continuous transfer mode does not support on USB IP0 port.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${config.driver.usb_basic.cntmd}" === "config.driver.usb_basic.cntmd.enable"))
        </constraint>
        <constraint display="The USBFS Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBFS Resume Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl_r}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl_r}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBFS D0FIFO Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl_d0}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl_d0}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBFS D1FIFO Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl_d1}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl_d1}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBHS Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.hsipl}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.hsipl}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBHS D0FIFO Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.hsipl_d0}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.hsipl_d0}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBHS D1FIFO Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.hsipl_d1}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.hsipl_d1}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="This MCU does not support USB LDO regulator.">
            !(!("${interface.mcu.ra4m1}" === "1") &amp;&amp;
            ("${config.driver.usb_basic.ldo_regulator}" === "config.driver.usb_basic.ldo_regulator.enable"))
        </constraint>
        <constraint display="The USBFS interrupt priority is lower than the DMAC interrupt priority. ">
             !(("${module.driver.usb_basic.usb_speed}" == "module.driver.usb_basic.usb_speed.fs") &amp;&amp;
               (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")) &amp;&amp;
               Number("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.ipl}".replace("board.icu.common.irq.priority","")) &gt;= Number("${module.driver.usb_basic.ipl}".replace("board.icu.common.irq.priority","")))
        </constraint>
        <constraint display="The USBFS interrupt priority is lower than the DMAC interrupt priority. ">
             !(("${module.driver.usb_basic.usb_speed}" == "module.driver.usb_basic.usb_speed.fs") &amp;&amp;
               (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")) &amp;&amp;
               Number("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.ipl}".replace("board.icu.common.irq.priority","")) &gt;= Number("${module.driver.usb_basic.ipl}".replace("board.icu.common.irq.priority","")))
        </constraint>
        <constraint display="The USBHS interrupt priority is lower than the DMAC interrupt priority. ">
             !(("${module.driver.usb_basic.usb_speed}" == "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
               (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")) &amp;&amp;
               Number("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.ipl}".replace("board.icu.common.irq.priority","")) &gt;= Number("${module.driver.usb_basic.hsipl}".replace("board.icu.common.irq.priority","")))
        </constraint>
        <constraint display="The USBHS interrupt priority is lower than the DMAC interrupt priority. ">
             !(("${module.driver.usb_basic.usb_speed}" == "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
               (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")) &amp;&amp;
               Number("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.ipl}".replace("board.icu.common.irq.priority","")) &gt;= Number("${module.driver.usb_basic.hsipl}".replace("board.icu.common.irq.priority","")))
        </constraint>
        <constraint display="Specify USBFS Interrupt Priority.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.usb_basic.ipl}" === "_disabled"))
        </constraint>
        <constraint display="Specify USBFS D0FIFO Interrupt Priority.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.usb_basic.ipl_d0}" === "_disabled") &amp;&amp;
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable"))
        </constraint>
        <constraint display="Specify USBFS D1FIFO Interrupt Priority.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.usb_basic.ipl_d1}" === "_disabled") &amp;&amp;
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable"))
        </constraint>
        <constraint display="Specify USBHS Interrupt Priority.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
               ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
               ("${module.driver.usb_basic.hsipl}" === "_disabled"))
        </constraint>
        <constraint display="Specify USBHS D0FIFO Interrupt Priority.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
               ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
               ("${module.driver.usb_basic.hsipl_d0}" === "_disabled") &amp;&amp;
               ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable"))
        </constraint>
        <constraint display="Specify USBHS D1FIFO Interrupt Priority.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
               ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
               ("${module.driver.usb_basic.hsipl_d1}" === "_disabled") &amp;&amp;
               ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable"))
        </constraint>
        <constraint display="When transmitting DMAC data using FS module, set the DMAC Activation Source to &quot;USBFS FIFO 1&quot;.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.activation_event}" !== "_signal.event.usbfs.fifo.1") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When transmitting DMAC data using HS module, set the DMAC Activation Source to &quot;USBHS FIFO 1&quot;. ">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.activation_event}" !== "_signal.event.usbhs.fifo.1") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When receiving DMA data using FS module, set the DMAC Activation Source to &quot;USBFS FIFO 0&quot;.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.activation_event}" !== "_signal.event.usbfs.fifo.0") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When receiving DMA data using HS module, set the DMAC Activation Source to &quot;USBHS FIFO 0&quot;.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.activation_event}" !== "_signal.event.usbhs.fifo.0") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When operating with HS module, set the transfer size to 4 bytes in the DMAC settings.  ">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.size}" !== "module.driver.transfer.size.size_4_byte") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When operating with FS module, set the transfer size to 2 bytes in the DMAC settings.  ">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.size}" !== "module.driver.transfer.size.size_2_byte") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When operating with HS module, set the transfer size to 4 bytes in the DMAC settings. ">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.size}" !== "module.driver.transfer.size.size_4_byte") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When operating with FS module, set the transfer size to 2 bytes in the DMAC settings. ">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.size}" !== "module.driver.transfer.size.size_2_byte") &amp;&amp;
            (testExists("${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="The OTG does not support DMAC.">
            !(("${module.driver.usb_basic.usb_mode}" === "module.driver.usb_basic.usb_mode.host_and_peri") &amp;&amp;
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.enable"))
        </constraint>
        <constraint display="The OTG can not use USB_IP1(High-speed module).">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.usb_basic.usb_mode}" === "module.driver.usb_basic.usb_mode.host_and_peri"))
        </constraint>
        <requires id="module.driver.basic_on_usb.requires.transfer_tx" interface="interface.driver.transfer_on_dmac" display="Add DMAC Driver for Transmission [Optional]" find="false" optional="true" >
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="USB_DEST_ADDRESS"/>
            <override property="module.driver.transfer.p_src" value="0"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.p_callback" value="usb_ip${module.driver.usb_basic.usb_modulenumber}_d1fifo_callback"/>
            <override property="module.driver.transfer.ipl" value="board.icu.common.irq.priority3"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.offset" value="0"/>
        </requires>
        <requires id="module.driver.basic_on_usb.requires.transfer_rx" interface="interface.driver.transfer_on_dmac" display="Add DMAC Driver for Reception [Optional]" find="false" optional="true" >
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="0"/>
            <override property="module.driver.transfer.p_src" value="USB_SRC_ADDRESS"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.ipl" value="board.icu.common.irq.priority3"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.offset" value="0"/>
        </requires>
        <requires id="module.driver.basic_on_usb.requires.basic" interface="interface.mcu.usb_fs.external" visible="false" display="Requires USB Peripheral" />
        <requires id="module.driver.transfer_on_dmac.requires.dmac" interface="interface.mcu.dma_dmac" visible="false" display="Requires DMAC peripheral" />
        <requires id="module.driver.basic_on_usb.requires.full_module" interface="interface.mcu.usb.pipes.0.1.2.3.4.5.6.7.8.9" visible="false" display="Requires USB Full Module" />
        <provides interface="interface.driver.basic.${module.driver.basic.name}" />
        <provides interface="interface.driver.basic" />
        <provides interface="interface.driver.basic_on_usb" />
        <provides interface="interface.peripheral.usbfs" />
        <provides interface="interface.peripheral.usbhs" />
        <property default="basic" id="module.driver.basic.basic_interface" description=""/>
        <property default="g_basic${_instance}" display="Name" id="module.driver.basic.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.driver.basic.name}")</constraint>
        </property>
        <property display="USB Mode" id="module.driver.usb_basic.usb_mode" default="module.driver.usb_basic.usb_mode.host" description="Select the usb mode.">
            <option id="module.driver.usb_basic.usb_mode.host" display="Host mode" value="USB_MODE_HOST" />
            <option id="module.driver.usb_basic.usb_mode.peri" display="Peri mode" value="USB_MODE_PERI" />
            <option id="module.driver.usb_basic.usb_mode.host_and_peri" display="OTG mode" value="USB_MODE_PERI" />
        </property>
        <property display="USB Speed" id="module.driver.usb_basic.usb_speed" default="module.driver.usb_basic.usb_speed.fs" description="Select the USB speed.">
            <option id="module.driver.usb_basic.usb_speed.fs" display="Full Speed" value="USB_SPEED_FS" />
            <option id="module.driver.usb_basic.usb_speed.hs" display="Hi Speed" value="USB_SPEED_HS" />
            <option id="module.driver.usb_basic.usb_speed.ls" display="Low Speed" value="USB_SPEED_LS" />
        </property>
        <property display="USB Module Number" id="module.driver.usb_basic.usb_modulenumber" default="module.driver.usb_basic.usb_modulenumber.0" description="Specify the USB module number to be used.">
            <option id="module.driver.usb_basic.usb_modulenumber.0" display="USB_IP0 Port" value="0" />
            <option id="module.driver.usb_basic.usb_modulenumber.1" display="USB_IP1 Port" value="1" />
        </property>
        <property display="USB Device Class" id="module.driver.usb_basic.usb_classtype" default="module.driver.usb_basic.usb_classtype.pcdc" description="Select the USB device class.">
            <option id="module.driver.usb_basic.usb_classtype.pcdc" display="Peripheral Communications Device Class" value="USB_CLASS_PCDC" />
            <option id="module.driver.usb_basic.usb_classtype.phid" display="Peripheral Human Interface Device Class" value="USB_CLASS_PHID" />
            <option id="module.driver.usb_basic.usb_classtype.pmsc" display="Peripheral Mass Storage Class" value="USB_CLASS_PMSC" />
            <option id="module.driver.usb_basic.usb_classtype.pvnd" display="Peripheral Vendor Class" value="USB_CLASS_PVND" />
            <option id="module.driver.usb_basic.usb_classtype.paud" display="Peripheral Audio Class" value="USB_CLASS_PAUD" />
            <option id="module.driver.usb_basic.usb_classtype.pprn" display="Peripheral Printer Class" value="USB_CLASS_PPRN" />
            <option id="module.driver.usb_basic.usb_classtype.hcdc" display="Host Communications Device Class" value="USB_CLASS_HCDC" />
            <option id="module.driver.usb_basic.usb_classtype.hhid" display="Host Human Interface Device Class" value="USB_CLASS_HHID" />
            <option id="module.driver.usb_basic.usb_classtype.hmsc" display="Host Mass Storage Class" value="USB_CLASS_HMSC" />
            <option id="module.driver.usb_basic.usb_classtype.hvnd" display="Host Vendor Class" value="USB_CLASS_HVND" />
            <option id="module.driver.usb_basic.usb_classtype.hprn" display="Host Printer Class" value="USB_CLASS_HPRN" />
            <option id="module.driver.usb_basic.usb_classtype.huvc" display="Host Video Class" value="USB_CLASS_HUVC" />
            <option id="module.driver.usb_basic.usb_classtype.dfu" display="DFU Class" value="USB_CLASS_DFU" />
        </property>
        <property display="USB Descriptor" id="module.driver.usb_basic.p_usb_reg" default="g_usb_descriptor" description="Enter the name of the descriptor to be used.\nFor how to create a descriptor structure, refer to the Descriptor definition chapter in the usb_basic manual.\nSpecify NULL when using the Host class.">
            <constraint display="USB Descriptor must be a valid C symbol.">testSymbol("${module.driver.usb_basic.p_usb_reg}")</constraint>
        </property>
        <property display="USB Compliance Callback" id="module.driver.usb_basic.complience_cb" default="NULL" description="Set the callback for compliance tests here.">
            <constraint display="Compliance Callback must be a valid C symbol.">testSymbol("${module.driver.usb_basic.complience_cb}")</constraint>
        </property>
        <property display="USBFS Interrupt Priority" id="module.driver.usb_basic.ipl" default="" description="Select the interrupt priority used by the main USBFS ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.int" isr="usbfs_interrupt_handler"/>
        </property>
        <property display="USBFS Resume Priority" id="module.driver.usb_basic.ipl_r" default="" description="Select the interrupt priority used by the USBFS Resume ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.resume" isr="usbfs_resume_handler"/>
        </property>
        <property display="USBFS D0FIFO Interrupt Priority" id="module.driver.usb_basic.ipl_d0" default="" description="Select the interrupt priority used by the USBFS D0FIFO.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.fifo.0" isr="usbfs_d0fifo_handler"/>
            <signal event="event.usbfs.fifo.0" />
        </property>
        <property display="USBFS D1FIFO Interrupt Priority" id="module.driver.usb_basic.ipl_d1" default="" description="Select the interrupt priority used by the USBFS D1FIFO.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.fifo.1" isr="usbfs_d1fifo_handler"/>
            <signal event="event.usbfs.fifo.1" />
        </property>
        <property display="USBHS Interrupt Priority" id="module.driver.usb_basic.hsipl" default="" description="Select the interrupt priority used by the main USBHS ISR.">
            <select enum="enum.driver.usb.hspriorities.mandatory"/>
            <interrupt event="event.usbhs.usb.int.resume" isr="usbhs_interrupt_handler"/>
        </property>
        <property display="USBHS D0FIFO Interrupt Priority" id="module.driver.usb_basic.hsipl_d0" default="" description="Select the interrupt priority used by the USBHS D0FIFO ISR.">
            <select enum="enum.driver.usb.hspriorities.mandatory"/>
            <interrupt event="event.usbhs.fifo.0" isr="usbhs_d0fifo_handler"/>
            <signal event="event.usbhs.fifo.0" />
        </property>
        <property display="USBHS D1FIFO Interrupt Priority" id="module.driver.usb_basic.hsipl_d1" default="" description="Select the interrupt priority used by the USBHS D1FIFO ISR.">
            <select enum="enum.driver.usb.hspriorities.mandatory"/>
            <interrupt event="event.usbhs.fifo.1" isr="usbhs_d1fifo_handler"/>
            <signal event="event.usbhs.fifo.1" />
        </property>
        <property display="USB Callback" id="module.driver.usb_basic.rtos_callback" default="NULL" description="A user callback function can be defined here.">
            <constraint display="Enter the address of the function.">testSymbol("${module.driver.usb_basic.rtos_callback}")</constraint>
        </property>
        <property display="USB Callback Context" id="module.driver.usb_basic.other_context" default="NULL" description="Set the callback context here.">
            <constraint display="Enter the address of the context.">testSymbol("${module.driver.usb_basic.other_context}")</constraint>
        </property>		
	<!-- List USB pins for MCU pinmappings that are generated with old MCU Utilities database -->
	<peripheral name="USB_FS" component="usbfs0" />
        <peripheral name="USB_HS" component="usbhs0" />		
	<!-- List USB pins for MCU pinmappings that are generated new MPC Designer tool -->
	<peripheral name="USB FS" component="usbfs" />
        <peripheral name="USB HS" component="usbhs" />
		
        <!-- symbol id -->
        <symbol id="symbol.driver.basic.name" value="${module.driver.basic.name}"/>
        <symbol id="symbol.driver.basic.guard.open" value="${module.driver.basic.name}_open_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.open" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Open"/>
        <symbol id="symbol.driver.basic.guard.close" value="${module.driver.basic.name}_close_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.close" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Close"/>
        <symbol id="symbol.driver.basic.guard.read" value="${module.driver.basic.name}_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Read"/>
        <symbol id="symbol.driver.basic.guard.write" value="${module.driver.basic.name}_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Write"/>
        <symbol id="symbol.driver.basic.guard.stop" value="${module.driver.basic.name}_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Stop"/>
        <symbol id="symbol.driver.basic.guard.suspend" value="${module.driver.basic.name}_suspend_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.suspend" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend"/>
        <symbol id="symbol.driver.basic.guard.resume" value="${module.driver.basic.name}_resume_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.resume" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Resume"/>
        <symbol id="symbol.driver.basic.guard.vbus_set" value="${module.driver.basic.name}_vbus_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.vbus_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet"/>
        <symbol id="symbol.driver.basic.guard.info_get" value="${module.driver.basic.name}_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_read" value="${module.driver.basic.name}_pipe_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead"/>
        <symbol id="symbol.driver.basic.guard.pipe_write" value="${module.driver.basic.name}_pipe_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite"/>
        <symbol id="symbol.driver.basic.guard.pipe_stop" value="${module.driver.basic.name}_pipe_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop"/>
        <symbol id="symbol.driver.basic.guard.used_pipes_get" value="${module.driver.basic.name}_used_pipes_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.used_pipes_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_info_get" value="${module.driver.basic.name}_pipe_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pull_up" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp"/>
        <symbol id="symbol.driver.basic.guard.event_get" value="${module.driver.basic.name}_event_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.event_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet"/>
        <symbol id="symbol.driver.basic.guard.callback" value="${module.driver.basic.name}_callback_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Callback"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet"/>
        <symbol id="symbol.driver.basic.guard.pull_up" value="${module.driver.basic.name}_pull_up_guard"/>
        <symbol id="symbol.driver.basic.guard.host_control_transfer" value="${module.driver.basic.name}_host_control_transfer_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.host_control_transfer" value="FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_get" value="${module.driver.basic.name}_peri_control_data_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_set" value="${module.driver.basic.name}_peri_control_data_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_status_set" value="${module.driver.basic.name}_peri_control_status_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_status_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet"/>
        <symbol id="symbol.driver.basic.guard.remote_wakeup" value="${module.driver.basic.name}_remote_wakeup_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.remote_wakeup" value="FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup"/>
        <symbol id="symbol.driver.basic.guard.module_number_get" value="${module.driver.basic.name}_module_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.module_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet"/>
        <symbol id="symbol.driver.basic.guard.class_type_get" value="${module.driver.basic.name}_class_type_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.class_type_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet"/>
        <symbol id="symbol.driver.basic.guard.device_address_get" value="${module.driver.basic.name}_device_address_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_address_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_number_get" value="${module.driver.basic.name}_pipe_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet"/>
        <symbol id="symbol.driver.basic.guard.device_state_get" value="${module.driver.basic.name}_device_state_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_state_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet"/>
        <symbol id="symbol.driver.basic.guard.data_size_get" value="${module.driver.basic.name}_data_size_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.data_size_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet"/>
        <symbol id="symbol.driver.basic.guard.setup_get" value="${module.driver.basic.name}_setup_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.setup_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet"/>
        <symbol id="symbol.driver.basic.guard.driver_activate" value="${module.driver.basic.name}_driver_activate_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.driver_activate" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate"/>
        <symbol id="symbol.driver.basic.guard.callback_memory_set" value="${module.driver.basic.name}_callback_memory_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback_memory_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet"/>
        <symbol id="symbol.driver.basic.nsc_api" value="${module.driver.basic.name}_nsc_api"/>
        <symbol id="symbol.driver.basic.cfg" value="${module.driver.basic.name}_cfg"/>
        <symbol id="symbol.driver.basic.mac_address" value="${module.driver.basic.name}_mac_address"/>
        <symbol id="symbol.driver.basic.num_tx_descriptions" value="${module.driver.basic.name}_tx_descriptions"/>
        <symbol id="symbol.driver.basic.num_rx_descriptions" value="${module.driver.basic.name}_rx_descriptions"/>
        <symbol id="symbol.driver.basic.ctrl" value="${module.driver.basic.name}_ctrl"/>

        <header>

/* Basic on USB Instance. */
extern const usb_instance_t ${module.driver.basic.name};

/** Access the USB instance using these structures when calling API functions directly (::p_api is not used). */
extern usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;
extern const usb_cfg_t ${module.driver.basic.name}_cfg;

#ifndef ${module.driver.usb_basic.complience_cb}
void ${module.driver.usb_basic.complience_cb}(void *);
#endif

#if 0 == BSP_CFG_RTOS
#ifndef ${module.driver.usb_basic.rtos_callback}
void ${module.driver.usb_basic.rtos_callback}(usb_callback_args_t *);
#endif
#endif

#if 2 == BSP_CFG_RTOS
#ifndef ${module.driver.usb_basic.rtos_callback}
void ${module.driver.usb_basic.rtos_callback}(usb_event_info_t *, usb_hdl_t, usb_onoff_t);
#endif
#endif

        </header>
        <includes>
#include &quot;r_usb_basic.h&quot;
#include &quot;r_usb_basic_api.h&quot;
        </includes>
        <declarations>

usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;

#if !defined(${module.driver.usb_basic.p_usb_reg})
extern usb_descriptor_t ${module.driver.usb_basic.p_usb_reg};
#endif
#define RA_NOT_DEFINED (1)
            const usb_cfg_t ${module.driver.basic.name}_cfg =
            {
                .usb_mode  = ${module.driver.usb_basic.usb_mode},
                .usb_speed = ${module.driver.usb_basic.usb_speed},
                .module_number = ${module.driver.usb_basic.usb_modulenumber},
                .type = ${module.driver.usb_basic.usb_classtype},
#if defined(${module.driver.usb_basic.p_usb_reg})
                .p_usb_reg = ${module.driver.usb_basic.p_usb_reg},
#else
                .p_usb_reg = &amp;${module.driver.usb_basic.p_usb_reg},
#endif
                .usb_complience_cb = ${module.driver.usb_basic.complience_cb},
#if defined(VECTOR_NUMBER_USBFS_INT)
                .irq       = VECTOR_NUMBER_USBFS_INT,
#else
                .irq       = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBFS_RESUME)
                .irq_r     = VECTOR_NUMBER_USBFS_RESUME,
#else
                .irq_r     = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBFS_FIFO_0)
                .irq_d0    = VECTOR_NUMBER_USBFS_FIFO_0,
#else
                .irq_d0    = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBFS_FIFO_1)
                .irq_d1    = VECTOR_NUMBER_USBFS_FIFO_1,
#else
                .irq_d1    = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBHS_USB_INT_RESUME)
                .hsirq     = VECTOR_NUMBER_USBHS_USB_INT_RESUME,
#else
                .hsirq     = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBHS_FIFO_0)
                .hsirq_d0  = VECTOR_NUMBER_USBHS_FIFO_0,
#else
                .hsirq_d0  = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBHS_FIFO_1)
                .hsirq_d1  = VECTOR_NUMBER_USBHS_FIFO_1,
#else
                .hsirq_d1  = FSP_INVALID_VECTOR,
#endif
                .ipl       = ${module.driver.usb_basic.ipl},
                .ipl_r     = ${module.driver.usb_basic.ipl_r},
                .ipl_d0    = ${module.driver.usb_basic.ipl_d0},
                .ipl_d1    = ${module.driver.usb_basic.ipl_d1},
                .hsipl     = ${module.driver.usb_basic.hsipl},
                .hsipl_d0  = ${module.driver.usb_basic.hsipl_d0},
                .hsipl_d1  = ${module.driver.usb_basic.hsipl_d1},
#if (BSP_CFG_RTOS == 0) &amp;&amp; defined(USB_CFG_HMSC_USE)
                .p_usb_apl_callback = NULL,
#else
                .p_usb_apl_callback = ${module.driver.usb_basic.rtos_callback},
#endif
#if defined(${module.driver.usb_basic.other_context})
                .p_context = ${module.driver.usb_basic.other_context},
#else
                .p_context = &amp;${module.driver.usb_basic.other_context},
#endif
#if (RA_NOT_DEFINED == ${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name})
#else
                .p_transfer_tx = &amp;${module.driver.basic_on_usb.requires.transfer_tx::module.driver.transfer.name},
#endif
#if (RA_NOT_DEFINED == ${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name})
#else
                .p_transfer_rx = &amp;${module.driver.basic_on_usb.requires.transfer_rx::module.driver.transfer.name},
#endif
            };
#undef RA_NOT_DEFINED

/* Instance structure to use this module. */
const usb_instance_t ${module.driver.basic.name} =
{
    .p_ctrl        = &amp;${module.driver.basic.name}_ctrl,
    .p_cfg         = &amp;${module.driver.basic.name}_cfg,
    .p_api         = &amp;g_usb_on_usb,
};
        </declarations>
        <guard>
            <header>

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);


            </header>
            <template name="${module.driver.basic.name}_guard.c">
                <![CDATA[
                    #include "guard.h"

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(cfg);

    return R_USB_Open(&${module.driver.basic.name}_ctrl, &${module.driver.basic.name}_cfg);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Close(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Read(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Write(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Stop(&${module.driver.basic.name}_ctrl, direction, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Suspend(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Resume(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_VbusSet(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    usb_info_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info == p_info_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_InfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeRead(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeWrite(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeStop(&${module.driver.basic.name}_ctrl, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint16_t *const p_pipe_checked = cmse_check_pointed_object(p_pipe, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_pipe == p_pipe_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_UsedPipesGet(&${module.driver.basic.name}_ctrl, p_pipe_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    usb_pipe_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info == p_info_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeInfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event)
{
    /* TODO: add your own security checks here */

    return R_USB_EventGet(p_api_ctrl, event);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback)
{
    /* Verify all pointers are in non-secure memory. */
    usb_callback_t *const p_callback_checked = cmse_check_pointed_object(p_callback, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback == p_callback_checked);

    return R_USB_Callback(p_callback_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PullUp(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address)
{
    /* Verify all pointers are in non-secure memory. */
    usb_setup_t *const p_setup_checked = cmse_check_pointed_object(p_setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_setup == p_setup_checked);
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, sizeof(usb_setup_t), CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_HostControlTransfer(&${module.driver.basic.name}_ctrl, p_setup_checked, p_buf_checked, device_address);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataGet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataSet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlStatusSet(&${module.driver.basic.name}_ctrl, status);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_RemoteWakeup(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * module_number_checked = cmse_check_pointed_object(module_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(module_number == module_number_checked);

    return R_USB_ModuleNumberGet(&${module.driver.basic.name}_ctrl, module_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_class_t * class_type_checked = cmse_check_pointed_object(class_type, CMSE_AU_NONSECURE);
    FSP_ASSERT(class_type == class_type_checked);

    return R_USB_ClassTypeGet(&${module.driver.basic.name}_ctrl, class_type_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * device_address_checked = cmse_check_pointed_object(device_address, CMSE_AU_NONSECURE);
    FSP_ASSERT(device_address == device_address_checked);

    return R_USB_DeviceAddressGet(&${module.driver.basic.name}_ctrl, device_address_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * pipe_number_checked = cmse_check_pointed_object(pipe_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(pipe_number == pipe_number_checked);

    return R_USB_PipeNumberGet(&${module.driver.basic.name}_ctrl, pipe_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint16_t * state_checked = cmse_check_pointed_object(state, CMSE_AU_NONSECURE);
    FSP_ASSERT(state == state_checked);

    return R_USB_DeviceStateGet(&${module.driver.basic.name}_ctrl, state_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint32_t * data_size_checked = cmse_check_pointed_object(data_size, CMSE_AU_NONSECURE);
    FSP_ASSERT(data_size == data_size_checked);

    return R_USB_DataSizeGet(&${module.driver.basic.name}_ctrl, data_size_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_setup_t * setup_checked = cmse_check_pointed_object(setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(setup == setup_checked);

    return R_USB_SetupGet(&${module.driver.basic.name}_ctrl, setup_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_DriverActivate(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_callback_args_t * p_callback_memory_checked = cmse_check_pointed_object((void *)p_callback_memory, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_memory_checked != NULL);


    return R_USB_CallbackMemorySet(&${module.driver.basic.name}_ctrl, p_callback_memory_checked);
}

                ]]>
            </template>
        </guard>
        <nsc>
            <header>

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Open() ${module.driver.basic.name}_open_guard(FSP_SECURE_ARGUMENT, FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Close() ${module.driver.basic.name}_close_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Read(p_buf, size, destination) ${module.driver.basic.name}_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Write(p_buf, size, destination) ${module.driver.basic.name}_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Stop(direction, destination) ${module.driver.basic.name}_stop_guard(FSP_SECURE_ARGUMENT, direction, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend() ${module.driver.basic.name}_suspend_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Resume() ${module.driver.basic.name}_resume_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet(state) ${module.driver.basic.name}_vbus_set_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet(p_info, destination) ${module.driver.basic.name}_info_get_guard(FSP_SECURE_ARGUMENT, p_info, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop(pipe_number) ${module.driver.basic.name}_pipe_stop_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet(p_pipe, destination) ${module.driver.basic.name}_used_pipes_get_guard(FSP_SECURE_ARGUMENT, p_pipe, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet(p_info, pipe_number) ${module.driver.basic.name}_pipe_info_get_guard(FSP_SECURE_ARGUMENT, p_info, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet(p_api_ctrl, event) ${module.driver.basic.name}_event_get_guard(p_api_ctrl, event)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Callback(p_callback) ${module.driver.basic.name}_callback_guard(p_callback)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp(state) ${module.driver.basic.name}_pull_up_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer(p_setup, p_buf, device_address) ${module.driver.basic.name}_host_control_transfer_guard(FSP_SECURE_ARGUMENT, p_setup, p_buf, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet(p_buf, size) ${module.driver.basic.name}_peri_control_data_get_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet(p_buf, size) ${module.driver.basic.name}_peri_control_data_set_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet(status) ${module.driver.basic.name}_peri_control_status_set_guard(FSP_SECURE_ARGUMENT, status)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup() ${module.driver.basic.name}_remote_wakeup_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet(module_number) ${module.driver.basic.name}_module_number_get_guard(FSP_SECURE_ARGUMENT, module_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet(class_type) ${module.driver.basic.name}_class_type_get_guard(FSP_SECURE_ARGUMENT, class_type)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet(device_address) ${module.driver.basic.name}_device_address_get_guard(FSP_SECURE_ARGUMENT, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet(pipe_number) ${module.driver.basic.name}_pipe_number_get_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet(state) ${module.driver.basic.name}_device_state_get_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet(data_size) ${module.driver.basic.name}_data_size_get_guard(FSP_SECURE_ARGUMENT, data_size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet(setup) ${module.driver.basic.name}_setup_get_guard(FSP_SECURE_ARGUMENT, setup)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate() ${module.driver.basic.name}_driver_activate_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet(p_callback_memory) ${module.driver.basic.name}_callback_memory_set_guard(FSP_SECURE_ARGUMENT, p_callback_memory)


BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);

extern const usb_instance_t ${module.driver.basic.name};

            </header>
            <declarations>
                <![CDATA[

static const usb_api_t ${module.driver.basic.name}_nsc_api =
{
    .open                  = ${module.driver.basic.name}_open_guard,
    .close                 = ${module.driver.basic.name}_close_guard,
    .read                  = ${module.driver.basic.name}_read_guard,
    .write                 = ${module.driver.basic.name}_write_guard,
    .stop                  = ${module.driver.basic.name}_stop_guard,
    .suspend               = ${module.driver.basic.name}_suspend_guard,
    .resume                = ${module.driver.basic.name}_resume_guard,

    .vbusSet               = ${module.driver.basic.name}_vbus_set_guard,
    .infoGet               = ${module.driver.basic.name}_info_get_guard,
    .pipeRead              = ${module.driver.basic.name}_pipe_read_guard,
    .pipeWrite             = ${module.driver.basic.name}_pipe_write_guard,
    .pipeStop              = ${module.driver.basic.name}_pipe_stop_guard,
    .usedPipesGet          = ${module.driver.basic.name}_used_pipes_get_guard,
    .pullUp                = ${module.driver.basic.name}_pull_up_guard,
    .eventGet              = ${module.driver.basic.name}_event_get_guard,
    .callback              = ${module.driver.basic.name}_callback_guard,
    .hostControlTransfer   = ${module.driver.basic.name}_host_control_transfer_guard,
    .periControlDataGet    = ${module.driver.basic.name}_peri_control_data_get_guard,
    .periControlDataSet    = ${module.driver.basic.name}_peri_control_data_set_guard,
    .periControlStatusSet  = ${module.driver.basic.name}_peri_control_status_set_guard,

    .remoteWakeup          = ${module.driver.basic.name}_remote_wakeup_guard,
    .moduleNumberGet       = ${module.driver.basic.name}_module_number_get_guard,
    .classTypeGet          = ${module.driver.basic.name}_class_type_get_guard,
    .deviceAddressGet      = ${module.driver.basic.name}_device_address_get_guard,
    .pipeNumberGet         = ${module.driver.basic.name}_pipe_number_get_guard,
    .deviceStateGet        = ${module.driver.basic.name}_device_state_get_guard,
    .dataSizeGet           = ${module.driver.basic.name}_data_size_get_guard,
    .setupGet              = ${module.driver.basic.name}_setup_get_guard,
    .driverActivate        = ${module.driver.basic.name}_driver_activate_guard,
    .callbackMemorySet     = ${module.driver.basic.name}_callback_memory_set_guard,
};
const usb_instance_t ${module.driver.basic.name} =
{
    .p_api = &${module.driver.basic.name}_nsc_api,
    .p_ctrl = FSP_SECURE_ARGUMENT,
    .p_cfg = FSP_SECURE_ARGUMENT,
};


                ]]>
            </declarations>
        </nsc>
    </module>

    <module config="config.driver.usb_basic" display="Connectivity|${module.driver.basic.name} USB (r_usb_basic)" id="module.driver.basic_on_usb_hhid" visible="false" version="0" url="group___u_s_b.html">
        <constraint display="Unique name required for each instance">
            "${interface.driver.basic.${module.driver.basic.name}}" === "1"
        </constraint>
        <constraint display="Requires USB Peripheral">
            "${interface.mcu.usb_fs.external}" === "1"
        </constraint>
        <constraint display="Requires USB clock to be 48 MHz">
          testExists("${board.clock.peripheral.usb}") &amp;&amp; (Number("${board.clock.peripheral.usb}") == 48000000)
        </constraint>
        <constraint display="This MCU does not support Hi-Speed mode.">
            !(!("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
            ("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs"))
        </constraint>
        <constraint display="This MCU only has one USB module (USB_IP0).">
            !(!("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
            ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1"))
        </constraint>
        <constraint display="USB_IP1 must be specified when using Hi-speed mode.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
            ("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
            ("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0"))
        </constraint>
        <constraint display="The FreeRTOS Max Priorities configuration must be set greater than or equal to 4.">
            (4 &lt;= &quot;${config.awsfreertos.thread.configmax_priorities}&quot;) ||
            !testExists("${interface.rtos.awsfreertos}")
        </constraint>
        <constraint display="&quot;Support Dynamic Allocation&quot; must be Enabled in FreeRTOS Thread &quot;setting|Common|Memory Allocation&quot;.">
            "${config.awsfreertos.thread.configsupport_dynamic_allocation}" === "config.awsfreertos.thread.configsupport_dynamic_allocation.enabled" ||
            "1" != "${interface.rtos.awsfreertos}"
        </constraint>
        <constraint display="Continuous transfer mode does not support on USB IP0 port.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${config.driver.usb_basic.cntmd}" === "config.driver.usb_basic.cntmd.enable"))
        </constraint>
        <constraint display="This driver does not support DMA.">
            ("${config.driver.usb_basic.dma}" === "config.driver.usb_basic.dma.disable")
        </constraint>
        <constraint display="This driver does not support Hi-speed.">
            !(("${interface.mcu.usb_hs.external}" === "1") &amp;&amp;
             ("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.hs") &amp;&amp;
             (("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.hhid") ||
              ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.phid") ||
              ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.dfu")) )
        </constraint>
        <constraint display="This driver does not support Low-speed.">
            !(("${module.driver.usb_basic.usb_speed}" === "module.driver.usb_basic.usb_speed.ls") &amp;&amp;
            ("${module.driver.usb_basic.usb_classtype}" === "module.driver.usb_basic.usb_classtype.phid"))
        </constraint>
        <constraint display="The USBFS Interrupt Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="The USBFS Resume Priority must be lower than the max syscall priority.">
            (("1" != "${interface.rtos.awsfreertos}") || (("${module.driver.usb_basic.ipl_r}" == "_disabled") ||
            (Number("${config.awsfreertos.thread.configlibrary_max_syscall_interrupt_priority}".replace("board.icu.common.irq.priority","")) &lt;= Number("${module.driver.usb_basic.ipl_r}".replace("board.icu.common.irq.priority","")))))
        </constraint>
        <constraint display="This MCU does not support USB LDO regulator.">
            !(!(("${interface.mcu.ra4m1}" === "1") || ("${interface.mcu.ra2a1}" === "1") ) &amp;&amp;
            ("${config.driver.usb_basic.ldo_regulator}" === "config.driver.usb_basic.ldo_regulator.enable"))
        </constraint>
        <constraint display="Specify USBFS Interrupt Priority.">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.0") &amp;&amp;
            ("${module.driver.usb_basic.ipl}" === "_disabled"))
        </constraint>
        <constraint display="The OTG can not use USB_IP1(High-speed module).">
            !(("${module.driver.usb_basic.usb_modulenumber}" === "module.driver.usb_basic.usb_modulenumber.1") &amp;&amp;
            ("${module.driver.usb_basic.usb_mode}" === "module.driver.usb_basic.usb_mode.host_and_peri"))
        </constraint>
        <requires id="module.driver.basic_on_usb.requires.basic" interface="interface.mcu.usb_fs.external" visible="false" display="Requires USB Peripheral" />
        <provides interface="interface.driver.basic.${module.driver.basic.name}" />
        <provides interface="interface.driver.basic" />
        <provides interface="interface.driver.basic_on_usb_hid" />
        <provides interface="interface.peripheral.usbfs" />
        <provides interface="interface.peripheral.usbhs" />
        <property default="basic" id="module.driver.basic.basic_interface" description=""/>
        <property default="g_basic${_instance}" display="Name" id="module.driver.basic.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.driver.basic.name}")</constraint>
        </property>
        <property display="USB Mode" id="module.driver.usb_basic.usb_mode" default="module.driver.usb_basic.usb_mode.peri" description="Select the usb mode.">
            <option id="module.driver.usb_basic.usb_mode.host" display="Host mode" value="USB_MODE_HOST" />
            <option id="module.driver.usb_basic.usb_mode.peri" display="Peri mode" value="USB_MODE_PERI" />
            <option id="module.driver.usb_basic.usb_mode.host_and_peri" display="OTG mode" value="USB_MODE_PERI" />
        </property>
        <property display="USB Speed" id="module.driver.usb_basic.usb_speed" default="module.driver.usb_basic.usb_speed.fs" description="Select the usb speed.">
            <option id="module.driver.usb_basic.usb_speed.fs" display="Full Speed" value="USB_SPEED_FS" />
            <option id="module.driver.usb_basic.usb_speed.hs" display="Hi Speed" value="USB_SPEED_HS" />
            <option id="module.driver.usb_basic.usb_speed.ls" display="Low Speed" value="USB_SPEED_LS" />
        </property>
        <property display="USB Module Number" id="module.driver.usb_basic.usb_modulenumber" default="module.driver.usb_basic.usb_modulenumber.0" description="Specify the USB module number to be used.">
            <option id="module.driver.usb_basic.usb_modulenumber.0" display="USB_IP0 Port" value="0" />
            <option id="module.driver.usb_basic.usb_modulenumber.1" display="USB_IP1 Port" value="1" />
        </property>
        <property display="USB Class Type" id="module.driver.usb_basic.usb_classtype" default="module.driver.usb_basic.usb_classtype.pcdc" description="Select the usb device class.">
            <option id="module.driver.usb_basic.usb_classtype.pcdc" display="Peripheral Communications Device Class" value="USB_CLASS_PCDC" />
            <option id="module.driver.usb_basic.usb_classtype.phid" display="Peripheral Human Interface Device Class" value="USB_CLASS_PHID" />
            <option id="module.driver.usb_basic.usb_classtype.pmsc" display="Peripheral Mass Storage Class" value="USB_CLASS_PMSC" />
            <option id="module.driver.usb_basic.usb_classtype.pvnd" display="Peripheral Vendor Class" value="USB_CLASS_PVND" />
            <option id="module.driver.usb_basic.usb_classtype.paud" display="Peripheral Audio Class" value="USB_CLASS_PAUD" />
            <option id="module.driver.usb_basic.usb_classtype.pprn" display="Peripheral Printer Class" value="USB_CLASS_PPRN" />
            <option id="module.driver.usb_basic.usb_classtype.hcdc" display="Host Communications Device Class" value="USB_CLASS_HCDC" />
            <option id="module.driver.usb_basic.usb_classtype.hhid" display="Host Human Interface Device Class" value="USB_CLASS_HHID" />
            <option id="module.driver.usb_basic.usb_classtype.hmsc" display="Host Mass Storage Class" value="USB_CLASS_HMSC" />
            <option id="module.driver.usb_basic.usb_classtype.hvnd" display="Host Vendor Class" value="USB_CLASS_HVND" />
            <option id="module.driver.usb_basic.usb_classtype.hprn" display="Host Printer Class" value="USB_CLASS_HPRN" />
            <option id="module.driver.usb_basic.usb_classtype.huvc" display="Host Video Class" value="USB_CLASS_HUVC" />
            <option id="module.driver.usb_basic.usb_classtype.dfu" display="DFU Class" value="USB_CLASS_DFU" />
        </property>
        <property display="USB Descriptor" id="module.driver.usb_basic.p_usb_reg" default="g_usb_descriptor" description="Enter the name of the descriptor to be used.\nFor how to create a descriptor structure, refer to the Descriptor definition chapter in the usb_basic manual.\nSpecify NULL when using the Host class.">
            <constraint display="USB Descriptor must be a valid C symbol.">testSymbol("${module.driver.usb_basic.p_usb_reg}")</constraint>
        </property>
        <property display="USB Compliance Callback" id="module.driver.usb_basic.complience_cb" default="NULL" description="Callback to be used for compliance tests.">
            <constraint display="Compliance Callback must be a valid C symbol.">testSymbol("${module.driver.usb_basic.complience_cb}")</constraint>
        </property>
        <property display="USBFS Interrupt Priority" id="module.driver.usb_basic.ipl" default="" description="Select the interrupt priority used by the main USBFS ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.int" isr="usbfs_interrupt_handler"/>
        </property>
        <property display="USBFS Resume Priority" id="module.driver.usb_basic.ipl_r" default="" description="Select the interrupt priority used by the USBFS Resume ISR.">
            <select enum="enum.driver.usb.fspriorities.mandatory"/>
            <interrupt event="event.usbfs.resume" isr="usbfs_resume_handler"/>
        </property>
        <property display="USBHS Interrupt Priority" id="module.driver.usb_basic.hsipl" default="" description="Select the interrupt priority used by the main USBHS ISR.">
            <select enum="enum.driver.usb.hspriorities.mandatory"/>
            <interrupt event="event.usbhs.usb.int.resume" isr="usbhs_interrupt_handler"/>
        </property>
        <property display="USB Callback" id="module.driver.usb_basic.rtos_callback" default="NULL" description="A user callback function can be defined here.">
            <constraint display="Enter the address of the function.">testSymbol("${module.driver.usb_basic.rtos_callback}")</constraint>
        </property>
        <property display="USB Callback Context" id="module.driver.usb_basic.other_context" default="NULL" description="Set the callback context here.">
            <constraint display="Enter the address of the context.">testSymbol("${module.driver.usb_basic.other_context}")</constraint>
        </property>
	<!-- List USB pins for MCU pinmappings that are generated with old MCU Utilities database -->
	<peripheral name="USB_FS" component="usbfs0" />
        <peripheral name="USB_HS" component="usbhs0" />		
	<!-- List USB pins for MCU pinmappings that are generated new MPC Designer tool -->
	<peripheral name="USB FS" component="usbfs" />
        <peripheral name="USB HS" component="usbhs" />

        <!-- symbol id -->
        <symbol id="symbol.driver.basic.name" value="${module.driver.basic.name}"/>
        <symbol id="symbol.driver.basic.guard.open" value="${module.driver.basic.name}_open_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.open" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Open"/>
        <symbol id="symbol.driver.basic.guard.close" value="${module.driver.basic.name}_close_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.close" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Close"/>
        <symbol id="symbol.driver.basic.guard.read" value="${module.driver.basic.name}_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Read"/>
        <symbol id="symbol.driver.basic.guard.write" value="${module.driver.basic.name}_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Write"/>
        <symbol id="symbol.driver.basic.guard.stop" value="${module.driver.basic.name}_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Stop"/>
        <symbol id="symbol.driver.basic.guard.suspend" value="${module.driver.basic.name}_suspend_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.suspend" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend"/>
        <symbol id="symbol.driver.basic.guard.resume" value="${module.driver.basic.name}_resume_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.resume" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Resume"/>
        <symbol id="symbol.driver.basic.guard.vbus_set" value="${module.driver.basic.name}_vbus_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.vbus_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet"/>
        <symbol id="symbol.driver.basic.guard.info_get" value="${module.driver.basic.name}_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_read" value="${module.driver.basic.name}_pipe_read_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_read" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead"/>
        <symbol id="symbol.driver.basic.guard.pipe_write" value="${module.driver.basic.name}_pipe_write_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_write" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite"/>
        <symbol id="symbol.driver.basic.guard.pipe_stop" value="${module.driver.basic.name}_pipe_stop_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_stop" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop"/>
        <symbol id="symbol.driver.basic.guard.used_pipes_get" value="${module.driver.basic.name}_used_pipes_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.used_pipes_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_info_get" value="${module.driver.basic.name}_pipe_info_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_info_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet"/>
        <symbol id="symbol.driver.basic.guard.pull_up" value="${module.driver.basic.name}_pull_up_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pull_up" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp"/>
        <symbol id="symbol.driver.basic.guard.event_get" value="${module.driver.basic.name}_event_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.event_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet"/>
        <symbol id="symbol.driver.basic.guard.callback" value="${module.driver.basic.name}_callback_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback" value="FSP_GUARD_${module.driver.basic.name}_R_USB_Callback"/>
        <symbol id="symbol.driver.basic.guard.host_control_transfer" value="${module.driver.basic.name}_host_control_transfer_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.host_control_transfer" value="FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_get" value="${module.driver.basic.name}_peri_control_data_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_data_set" value="${module.driver.basic.name}_peri_control_data_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_data_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet"/>
        <symbol id="symbol.driver.basic.guard.peri_control_status_set" value="${module.driver.basic.name}_peri_control_status_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.peri_control_status_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet"/>
        <symbol id="symbol.driver.basic.guard.remote_wakeup" value="${module.driver.basic.name}_remote_wakeup_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.remote_wakeup" value="FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup"/>
        <symbol id="symbol.driver.basic.guard.module_number_get" value="${module.driver.basic.name}_module_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.module_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet"/>
        <symbol id="symbol.driver.basic.guard.class_type_get" value="${module.driver.basic.name}_class_type_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.class_type_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet"/>
        <symbol id="symbol.driver.basic.guard.device_address_get" value="${module.driver.basic.name}_device_address_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_address_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet"/>
        <symbol id="symbol.driver.basic.guard.pipe_number_get" value="${module.driver.basic.name}_pipe_number_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.pipe_number_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet"/>
        <symbol id="symbol.driver.basic.guard.device_state_get" value="${module.driver.basic.name}_device_state_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.device_state_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet"/>
        <symbol id="symbol.driver.basic.guard.data_size_get" value="${module.driver.basic.name}_data_size_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.data_size_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet"/>
        <symbol id="symbol.driver.basic.guard.setup_get" value="${module.driver.basic.name}_setup_get_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.setup_get" value="FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet"/>
        <symbol id="symbol.driver.basic.guard.driver_activate" value="${module.driver.basic.name}_driver_activate_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.driver_activate" value="FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate"/>
        <symbol id="symbol.driver.basic.guard.callback_memory_set" value="${module.driver.basic.name}_callback_memory_set_guard"/>
        <symbol id="symbol.driver.basic.guard.macro.callback_memory_set" value="FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet"/>
        <symbol id="symbol.driver.basic.nsc_api" value="${module.driver.basic.name}_nsc_api"/>
        <symbol id="symbol.driver.basic.cfg" value="${module.driver.basic.name}_cfg"/>
        <symbol id="symbol.driver.basic.mac_address" value="${module.driver.basic.name}_mac_address"/>
        <symbol id="symbol.driver.basic.num_tx_descriptions" value="${module.driver.basic.name}_tx_descriptions"/>
        <symbol id="symbol.driver.basic.num_rx_descriptions" value="${module.driver.basic.name}_rx_descriptions"/>
        <symbol id="symbol.driver.basic.ctrl" value="${module.driver.basic.name}_ctrl"/>

        <header>

/* Basic on USB Instance. */
extern const usb_instance_t ${module.driver.basic.name};

/** Access the USB instance using these structures when calling API functions directly (::p_api is not used). */
extern usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;
extern const usb_cfg_t ${module.driver.basic.name}_cfg;

#ifndef ${module.driver.usb_basic.complience_cb}
void ${module.driver.usb_basic.complience_cb}(void *);
#endif

#if 0 == BSP_CFG_RTOS
#ifndef ${module.driver.usb_basic.rtos_callback}
void ${module.driver.usb_basic.rtos_callback}(usb_callback_args_t *);
#endif
#endif

#if 2 == BSP_CFG_RTOS
#ifndef ${module.driver.usb_basic.rtos_callback}
void ${module.driver.usb_basic.rtos_callback}(usb_event_info_t *, usb_hdl_t, usb_onoff_t);
#endif
#endif
        </header>
        <includes>
#include &quot;r_usb_basic.h&quot;
#include &quot;r_usb_basic_api.h&quot;
        </includes>
        <declarations>

usb_instance_ctrl_t ${module.driver.basic.name}_ctrl;

#if !defined(${module.driver.usb_basic.p_usb_reg})
extern usb_descriptor_t ${module.driver.usb_basic.p_usb_reg};
#endif
#define RA_NOT_DEFINED (1)
            const usb_cfg_t ${module.driver.basic.name}_cfg =
            {
                .usb_mode  = ${module.driver.usb_basic.usb_mode},
                .usb_speed = ${module.driver.usb_basic.usb_speed},
                .module_number = ${module.driver.usb_basic.usb_modulenumber},
                .type = ${module.driver.usb_basic.usb_classtype},
#if defined(${module.driver.usb_basic.p_usb_reg})
                .p_usb_reg = ${module.driver.usb_basic.p_usb_reg},
#else
                .p_usb_reg = &amp;${module.driver.usb_basic.p_usb_reg},
#endif
                .usb_complience_cb = ${module.driver.usb_basic.complience_cb},
#if defined(VECTOR_NUMBER_USBFS_INT)
                .irq       = VECTOR_NUMBER_USBFS_INT,
#else
                .irq       = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_USBFS_RESUME)
                .irq_r     = VECTOR_NUMBER_USBFS_RESUME,
#else
                .irq_r     = FSP_INVALID_VECTOR,
#endif
                .irq_d0    = FSP_INVALID_VECTOR,
                .irq_d1    = FSP_INVALID_VECTOR,
#if defined(VECTOR_NUMBER_USBHS_USB_INT_RESUME)
                .hsirq     = VECTOR_NUMBER_USBHS_USB_INT_RESUME,
#else
                .hsirq     = FSP_INVALID_VECTOR,
#endif
                .hsirq_d0  = FSP_INVALID_VECTOR,
                .hsirq_d1  = FSP_INVALID_VECTOR,
                .ipl       = ${module.driver.usb_basic.ipl},
                .ipl_r     = ${module.driver.usb_basic.ipl_r},
                .ipl_d0    = BSP_IRQ_DISABLED,
                .ipl_d1    = BSP_IRQ_DISABLED,
                .hsipl     = ${module.driver.usb_basic.hsipl},
                .hsipl_d0  = BSP_IRQ_DISABLED,
                .hsipl_d1  = BSP_IRQ_DISABLED,
#if (BSP_CFG_RTOS == 0) &amp;&amp; defined(USB_CFG_HMSC_USE)
                .p_usb_apl_callback = NULL,
#else
                .p_usb_apl_callback = ${module.driver.usb_basic.rtos_callback},
#endif
#if defined(${module.driver.usb_basic.other_context})
                .p_context = ${module.driver.usb_basic.other_context},
#else
                .p_context = &amp;${module.driver.usb_basic.other_context},
#endif
            };
#undef RA_NOT_DEFINED

/* Instance structure to use this module. */
const usb_instance_t ${module.driver.basic.name} =
{
    .p_ctrl        = &amp;${module.driver.basic.name}_ctrl,
    .p_cfg         = &amp;${module.driver.basic.name}_cfg,
    .p_api         = &amp;g_usb_on_usb,
};
        </declarations>

        <guard>
            <header>

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);

            </header>
            <template name="${module.driver.basic.name}_guard.c">
                <![CDATA[
                    #include "guard.h"

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(cfg);

    return R_USB_Open(&${module.driver.basic.name}_ctrl, &${module.driver.basic.name}_cfg);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Close(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Read(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Write(&${module.driver.basic.name}_ctrl, p_buf_checked, size, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Stop(&${module.driver.basic.name}_ctrl, direction, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Suspend(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_Resume(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_VbusSet(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    usb_info_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info == p_info_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_InfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeRead(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeWrite(&${module.driver.basic.name}_ctrl, p_buf_checked, size, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeStop(&${module.driver.basic.name}_ctrl, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination)
{
    /* Verify all pointers are in non-secure memory. */
    uint16_t *const p_pipe_checked = cmse_check_pointed_object(p_pipe, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_pipe == p_pipe_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_UsedPipesGet(&${module.driver.basic.name}_ctrl, p_pipe_checked, destination);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number)
{
    /* Verify all pointers are in non-secure memory. */
    usb_pipe_t *const p_info_checked = cmse_check_pointed_object(p_info, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_info == p_info_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PipeInfoGet(&${module.driver.basic.name}_ctrl, p_info_checked, pipe_number);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event)
{
    /* TODO: add your own security checks here */

    return R_USB_EventGet(p_api_ctrl, event);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback)
{
    /* Verify all pointers are in non-secure memory. */
    usb_callback_t *const p_callback_checked = cmse_check_pointed_object(p_callback, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback == p_callback_checked);

    return R_USB_Callback(p_callback_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PullUp(&${module.driver.basic.name}_ctrl, state);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address)
{
    /* Verify all pointers are in non-secure memory. */
    usb_setup_t *const p_setup_checked = cmse_check_pointed_object(p_setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_setup == p_setup_checked);
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, sizeof(usb_setup_t), CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_HostControlTransfer(&${module.driver.basic.name}_ctrl, p_setup_checked, p_buf_checked, device_address);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataGet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size)
{
    /* Verify all pointers are in non-secure memory. */
    uint8_t *const p_buf_checked = cmse_check_address_range((void *)p_buf, size, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_buf == p_buf_checked);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlDataSet(&${module.driver.basic.name}_ctrl, p_buf_checked, size);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_PeriControlStatusSet(&${module.driver.basic.name}_ctrl, status);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_RemoteWakeup(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * module_number_checked = cmse_check_pointed_object(module_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(module_number == module_number_checked);

    return R_USB_ModuleNumberGet(&${module.driver.basic.name}_ctrl, module_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_class_t * class_type_checked = cmse_check_pointed_object(class_type, CMSE_AU_NONSECURE);
    FSP_ASSERT(class_type == class_type_checked);

    return R_USB_ClassTypeGet(&${module.driver.basic.name}_ctrl, class_type_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * device_address_checked = cmse_check_pointed_object(device_address, CMSE_AU_NONSECURE);
    FSP_ASSERT(device_address == device_address_checked);

    return R_USB_DeviceAddressGet(&${module.driver.basic.name}_ctrl, device_address_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint8_t * pipe_number_checked = cmse_check_pointed_object(pipe_number, CMSE_AU_NONSECURE);
    FSP_ASSERT(pipe_number == pipe_number_checked);

    return R_USB_PipeNumberGet(&${module.driver.basic.name}_ctrl, pipe_number_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint16_t * state_checked = cmse_check_pointed_object(state, CMSE_AU_NONSECURE);
    FSP_ASSERT(state == state_checked);

    return R_USB_DeviceStateGet(&${module.driver.basic.name}_ctrl, state_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    uint32_t * data_size_checked = cmse_check_pointed_object(data_size, CMSE_AU_NONSECURE);
    FSP_ASSERT(data_size == data_size_checked);

    return R_USB_DataSizeGet(&${module.driver.basic.name}_ctrl, data_size_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_setup_t * setup_checked = cmse_check_pointed_object(setup, CMSE_AU_NONSECURE);
    FSP_ASSERT(setup == setup_checked);

    return R_USB_SetupGet(&${module.driver.basic.name}_ctrl, setup_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_USB_DriverActivate(&${module.driver.basic.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    /* Verify all pointers are in non-secure memory. */
    usb_callback_args_t * p_callback_memory_checked = cmse_check_pointed_object((void *)p_callback_memory, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_memory_checked != NULL);


    return R_USB_CallbackMemorySet(&${module.driver.basic.name}_ctrl, p_callback_memory_checked);
}

                ]]>
            </template>
        </guard>
        <nsc>
            <header>

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Open() ${module.driver.basic.name}_open_guard(FSP_SECURE_ARGUMENT, FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Close() ${module.driver.basic.name}_close_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Read(p_buf, size, destination) ${module.driver.basic.name}_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Write(p_buf, size, destination) ${module.driver.basic.name}_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Stop(direction, destination) ${module.driver.basic.name}_stop_guard(FSP_SECURE_ARGUMENT, direction, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Suspend() ${module.driver.basic.name}_suspend_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Resume() ${module.driver.basic.name}_resume_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_VbusSet(state) ${module.driver.basic.name}_vbus_set_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_InfoGet(p_info, destination) ${module.driver.basic.name}_info_get_guard(FSP_SECURE_ARGUMENT, p_info, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeRead(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_read_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeWrite(p_buf, size, pipe_number) ${module.driver.basic.name}_pipe_write_guard(FSP_SECURE_ARGUMENT, p_buf, size, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeStop(pipe_number) ${module.driver.basic.name}_pipe_stop_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_UsedPipesGet(p_pipe, destination) ${module.driver.basic.name}_used_pipes_get_guard(FSP_SECURE_ARGUMENT, p_pipe, destination)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeInfoGet(p_info, pipe_number) ${module.driver.basic.name}_pipe_info_get_guard(FSP_SECURE_ARGUMENT, p_info, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_EventGet(p_api_ctrl, event) ${module.driver.basic.name}_event_get_guard(p_api_ctrl, event)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_Callback(p_callback) ${module.driver.basic.name}_callback_guard(p_callback)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PullUp(state) ${module.driver.basic.name}_pull_up_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_HostControlTransfer(p_setup, p_buf, device_address) ${module.driver.basic.name}_host_control_transfer_guard(FSP_SECURE_ARGUMENT, p_setup, p_buf, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataGet(p_buf, size) ${module.driver.basic.name}_peri_control_data_get_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlDataSet(p_buf, size) ${module.driver.basic.name}_peri_control_data_set_guard(FSP_SECURE_ARGUMENT, p_buf, size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PeriControlStatusSet(status) ${module.driver.basic.name}_peri_control_status_set_guard(FSP_SECURE_ARGUMENT, status)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_RemoteWakeup() ${module.driver.basic.name}_remote_wakeup_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ModuleNumberGet(module_number) ${module.driver.basic.name}_module_number_get_guard(FSP_SECURE_ARGUMENT, module_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_ClassTypeGet(class_type) ${module.driver.basic.name}_class_type_get_guard(FSP_SECURE_ARGUMENT, class_type)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceAddressGet(device_address) ${module.driver.basic.name}_device_address_get_guard(FSP_SECURE_ARGUMENT, device_address)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_PipeNumberGet(pipe_number) ${module.driver.basic.name}_pipe_number_get_guard(FSP_SECURE_ARGUMENT, pipe_number)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DeviceStateGet(state) ${module.driver.basic.name}_device_state_get_guard(FSP_SECURE_ARGUMENT, state)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DataSizeGet(data_size) ${module.driver.basic.name}_data_size_get_guard(FSP_SECURE_ARGUMENT, data_size)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_SetupGet(setup) ${module.driver.basic.name}_setup_get_guard(FSP_SECURE_ARGUMENT, setup)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_DriverActivate() ${module.driver.basic.name}_driver_activate_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.basic.name}_R_USB_CallbackMemorySet(p_callback_memory) ${module.driver.basic.name}_callback_memory_set_guard(FSP_SECURE_ARGUMENT, p_callback_memory)



BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_open_guard(usb_ctrl_t * const p_api_ctrl, usb_cfg_t const * const cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_close_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t const * const p_buf, uint32_t size, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_stop_guard(usb_ctrl_t * const p_api_ctrl, usb_transfer_t direction, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_suspend_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_resume_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_vbus_set_guard(usb_ctrl_t * const p_api_ctrl, uint16_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_info_t * p_info, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_read_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_write_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_stop_guard(usb_ctrl_t * const p_api_ctrl, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_used_pipes_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * p_pipe, uint8_t destination);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_info_get_guard(usb_ctrl_t * const p_api_ctrl, usb_pipe_t * p_info, uint8_t pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_event_get_guard(usb_ctrl_t * const p_api_ctrl, usb_status_t * event);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_guard(usb_callback_t * p_callback);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pull_up_guard(usb_ctrl_t * const p_api_ctrl, uint8_t state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_host_control_transfer_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * p_setup, uint8_t * p_buf, uint8_t device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_data_set_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * p_buf, uint32_t size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_peri_control_status_set_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_status_t status);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_remote_wakeup_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_module_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * module_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_class_type_get_guard(usb_ctrl_t * const p_api_ctrl, usb_class_t * class_type);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_address_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * device_address);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_pipe_number_get_guard(usb_ctrl_t * const p_api_ctrl, uint8_t * pipe_number);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_device_state_get_guard(usb_ctrl_t * const p_api_ctrl, uint16_t * state);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_data_size_get_guard(usb_ctrl_t * const p_api_ctrl, uint32_t * data_size);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_setup_get_guard(usb_ctrl_t * const p_api_ctrl, usb_setup_t * setup);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_driver_activate_guard(usb_ctrl_t * const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.basic.name}_callback_memory_set_guard(usb_ctrl_t * const p_api_ctrl, usb_callback_args_t * p_callback_memory);


extern const usb_instance_t ${module.driver.basic.name};

            </header>
            <declarations>
                <![CDATA[

static const usb_api_t ${module.driver.basic.name}_nsc_api =
{
    .open                  = ${module.driver.basic.name}_open_guard,
    .close                 = ${module.driver.basic.name}_close_guard,
    .read                  = ${module.driver.basic.name}_read_guard,
    .write                 = ${module.driver.basic.name}_write_guard,
    .stop                  = ${module.driver.basic.name}_stop_guard,
    .suspend               = ${module.driver.basic.name}_suspend_guard,
    .resume                = ${module.driver.basic.name}_resume_guard,

    .vbusSet               = ${module.driver.basic.name}_vbus_set_guard,
    .infoGet               = ${module.driver.basic.name}_info_get_guard,
    .pipeRead              = ${module.driver.basic.name}_pipe_read_guard,
    .pipeWrite             = ${module.driver.basic.name}_pipe_write_guard,
    .pipeStop              = ${module.driver.basic.name}_pipe_stop_guard,
    .usedPipesGet          = ${module.driver.basic.name}_used_pipes_get_guard,
    .pullUp                = ${module.driver.basic.name}_pull_up_guard,
    .eventGet              = ${module.driver.basic.name}_event_get_guard,
    .callback              = ${module.driver.basic.name}_callback_guard,
    .hostControlTransfer   = ${module.driver.basic.name}_host_control_transfer_guard,
    .periControlDataGet    = ${module.driver.basic.name}_peri_control_data_get_guard,
    .periControlDataSet    = ${module.driver.basic.name}_peri_control_data_set_guard,
    .periControlStatusSet  = ${module.driver.basic.name}_peri_control_status_set_guard,

    .remoteWakeup          = ${module.driver.basic.name}_remote_wakeup_guard,
    .moduleNumberGet       = ${module.driver.basic.name}_module_number_get_guard,
    .classTypeGet          = ${module.driver.basic.name}_class_type_get_guard,
    .deviceAddressGet      = ${module.driver.basic.name}_device_address_get_guard,
    .pipeNumberGet         = ${module.driver.basic.name}_pipe_number_get_guard,
    .deviceStateGet        = ${module.driver.basic.name}_device_state_get_guard,
    .dataSizeGet           = ${module.driver.basic.name}_data_size_get_guard,
    .setupGet              = ${module.driver.basic.name}_setup_get_guard,
    .driverActivate        = ${module.driver.basic.name}_driver_activate_guard,
    .callbackMemorySet     = ${module.driver.basic.name}_callback_memory_set_guard,
};
const usb_instance_t ${module.driver.basic.name} =
{
    .p_api = &${module.driver.basic.name}_nsc_api,
    .p_ctrl = FSP_SECURE_ARGUMENT,
    .p_cfg = FSP_SECURE_ARGUMENT,
};


                ]]>
            </declarations>
        </nsc>

    </module>
</raModuleDescription>
