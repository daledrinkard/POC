<?xml version="1.0"?>
<raModuleDescription>
    <config id="config.driver.sci_b_lin" path="fsp_cfg/r_sci_b_lin_cfg.h" version="0">
        <property default="config.driver.sci_b_lin.param_checking_enable.bsp" display="Parameter Checking" id="config.driver.sci_b_lin.param_checking_enable" description="If selected code for parameter checking is included in the build.">
            <option display="Default (BSP)" id="config.driver.sci_b_lin.param_checking_enable.bsp" value="(BSP_CFG_PARAM_CHECKING_ENABLE)" />
            <option display="Enabled" id="config.driver.sci_b_lin.param_checking_enable.enabled" value="(1)" />
            <option display="Disabled" id="config.driver.sci_b_lin.param_checking_enable.disabled" value="(0)" />
        </property>
        <property default="config.driver.sci_b_lin.checksum_support.enabled" display="Checksum Support" id="config.driver.sci_b_lin.checksum_support" description="When set to 'Disabled', code for checksum generation and validation is excluded from the build. This setting is applied globally to the project. Disable only when checksum generation and validation is not required for any LIN instance.">
            <option display="Enabled" id="config.driver.sci_b_lin.checksum_support.enabled" value="(1)" />
            <option display="Disabled" id="config.driver.sci_b_lin.checksum_support.disabled" value="(0)" />
        </property>
        <property default="config.driver.sci_b_lin.auto_synchronization_support.disabled" display="Auto Synchronization Support" id="config.driver.sci_b_lin.auto_synchronization_support" description="When set to 'Disabled', code for auto synchronization is excluded from the build. This setting is applied globally to the project. Enable when at least one LIN slave instance is using auto synchronization.">
            <option display="Enabled" id="config.driver.sci_b_lin.auto_synchronization_support.enabled" value="(1)" />
            <option display="Disabled" id="config.driver.sci_b_lin.auto_synchronization_support.disabled" value="(0)" />
        </property>
        <content>
            #ifdef __cplusplus
            extern "C" {
            #endif

            #define SCI_B_LIN_CFG_PARAM_CHECKING_ENABLE ${config.driver.sci_b_lin.param_checking_enable}
            #define SCI_B_LIN_CHECKSUM_SUPPORT_ENABLE ${config.driver.sci_b_lin.checksum_support}
            #define SCI_B_LIN_AUTO_SYNC_SUPPORT_ENABLE ${config.driver.sci_b_lin.auto_synchronization_support}

            #ifdef __cplusplus
            }
            #endif
        </content>
    </config>
    <module config="config.driver.sci_b_lin" display="Connectivity|${module.driver.sci_b_lin.name} LIN (r_sci_b_lin)" id="module.driver.lin_on_sci_b_lin" version="1" url="group___s_c_i___b___l_i_n.html">
        <constraint display="Requires callback to be a C function name (not NULL).">
          (testSymbol("${module.driver.sci_b_lin.callback}") &amp;&amp; "${module.driver.sci_b_lin.callback}" != "NULL")
        </constraint>
        <constraint display="Specified 'Baud Rate' is not available on selected MCU.">
            testInteger("${module.driver.sci_b_lin.baud}") &amp;&amp; ("${module.driver.sci_b_lin.baud}" &gt; 0) &amp;&amp; ("${module.driver.sci_b_lin.baud}" &lt;= (Number("${config.bsp.fsp.mcu.sci_b_lin.max_baud}")))
        </constraint>
        <constraint display="Unique name required for each instance">
            ("${interface.driver.lin.${module.driver.sci_b_lin.name}}" === "1")
        </constraint>
        <constraint display="Requires SCI Peripheral">
            "${interface.mcu.sci_b.external}" === "1"
        </constraint>
        <constraint display="Requires SCISPICLK/SCICLK to be enabled on the Clocks tab.">
            ${board.clock.peripheral.sciclk} &gt; 0 || "${module.driver.sci_b_lin.clock_source}" === "enum.driver.sci_b.clock_source.pclk"
        </constraint>
        <constraint display="Auto Synchronization Support must be enabled to use Auto Synchronization.">
            (("${config.driver.sci_b_lin.auto_synchronization_support}" === "config.driver.sci_b_lin.auto_synchronization_support.enabled") ||
            ("${module.driver.sci_b_lin.auto_synchronization}" === "module.driver.sci_b_lin.auto_synchronization.disabled"))
        </constraint>
        <constraint display="AED Interrupt must be enabled to use Auto Synchronization.">
            (("${module.driver.sci_b_lin.auto_synchronization}" === "module.driver.sci_b_lin.auto_synchronization.disabled") ||
            ("${module.driver.sci_b_lin.aed_ipl}" != "_disabled"))
        </constraint>
        <constraint display="BFD Interrupt must be enabled in slave mode.">
            "${module.driver.sci_b_lin.mode}" === "module.driver.sci_b_lin.mode.mode_master" || ("${module.driver.sci_b_lin.bfd_ipl}" != "_disabled")
        </constraint>
        <constraint display="BFD Interrupt must be disabled in master mode.">
            "${module.driver.sci_b_lin.mode}" === "module.driver.sci_b_lin.mode.mode_slave" || ("${module.driver.sci_b_lin.bfd_ipl}" === "_disabled")
        </constraint>
        <constraint display="AED Interrupt must be disabled in master mode.">
            "${module.driver.sci_b_lin.mode}" === "module.driver.sci_b_lin.mode.mode_slave" || ("${module.driver.sci_b_lin.aed_ipl}" === "_disabled")
        </constraint>
            <constraint display="Auto Synchronization must be disabled in master mode.">
            "${module.driver.sci_b_lin.mode}" === "module.driver.sci_b_lin.mode.mode_slave" || ("${module.driver.sci_b_lin.auto_synchronization}" === "module.driver.sci_b_lin.auto_synchronization.disabled")
        </constraint>
        <constraint display="Break field length in master mode must be at least 13 bits.">
           "${module.driver.sci_b_lin.mode}" == "module.driver.sci_b_lin.mode.mode_slave" || ${module.driver.sci_b_lin.break_field_bits} &gt; 12
        </constraint>
            <constraint display="Break field detection threshold in slave mode must be at least 11 bits.">
           "${module.driver.sci_b_lin.mode}" == "module.driver.sci_b_lin.mode.mode_master" || ${module.driver.sci_b_lin.break_field_bits} &gt; 10
        </constraint>
        <!-- Check that selected settings for break field length/threshold are achievable in the HW -->
        <constraint id="module.driver.sci_b_lin.constraint.lin_timer">
            eval('\n' +
                 ' var break_field_bits = ${module.driver.sci_b_lin.break_field_bits}; \n' +
                 ' var baud = ${module.driver.sci_b_lin.baud};  \n' +
                 ' var clock_source = "${module.driver.sci_b_lin.clock_source}";  \n' +
                 ' var freq_hz = ${board.clock.peripheral.sciclk}; \n' +
                 ' if ("enum.driver.sci_b.clock_source.pclk" === clock_source) { \n' +
                 '    freq_hz = ${board.clock.peripheral.sci_b}; \n' +
                 ' } \n' +
                 ' var timer_div = "${module.driver.sci_b_lin.timer_div}"; \n' +
                 ' var lin_divider = 4; \n' +
                 ' if ("module.driver.sci_b_lin.timer_div.div_16" === timer_div) { \n' +
                 '    lin_divider = 16; \n' +
                 ' } \n' +
                 ' if ("module.driver.sci_b_lin.timer_div.div_64" === timer_div) { \n' +
                 '    lin_divider = 64; \n' +
                 ' } \n' +
                 'var lin_timer_hz = freq_hz / lin_divider; \n' +
                 'var output = null; \n' +
                 'var bflw_setting = Math.floor( (lin_timer_hz * break_field_bits) / ( baud ) ) - 1;  \n' +
                 'var max = 0xfffe; \n' +
                 'if (bflw_setting > max) { \n' +
                    'output = " LIN timer break field width/threshold setting exceeds maximum (65534).\\n BFLW = ( ( TCLK / (LIN Timer Divider) * (Break Field Bits) ) / (Baud Rate) ) - 1 \\n = ( ( (" + freq_hz + "/" + lin_divider + ") *" + break_field_bits + ") / (" + baud + ") ) - 1 = " + bflw_setting + "\\n Adjust LIN source clock, divider, break field bits, or baud rate."; \n' +
                 '} \n' +
                 'output')
        </constraint>
        <requires id="module.driver.lin_on_sci_b_lin.requires.sci_b" interface="interface.mcu.sci_b.external" visible="false" display="Requires SCI Peripheral" />
        <provides interface="interface.driver.lin" />
        <provides interface="interface.driver.lin_on_sci_b_lin" />
        <provides interface="interface.driver.lin.${module.driver.sci_b_lin.name}" />
        <provides interface="interface.peripheral.sci${module.driver.sci_b_lin.channel}" />

        <!-- LIN General Configuration -->
        <property default="g_lin${_instance}" display="General|Name" id="module.driver.sci_b_lin.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">
                testSymbol("${module.driver.sci_b_lin.name}")
            </constraint>
        </property>
        <property default="" display="General|Channel" id="module.driver.sci_b_lin.channel" description="Select the LIN channel.">
            <select enum="enum.driver.sci_b.lin.channel" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.rxi" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.txi" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.tei" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.eri" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.bfd" />
            <signal event="event.sci${module.driver.sci_b_lin.channel}.aed" />
        </property>
        <property default="module.driver.sci_b_lin.mode.mode_master" display="General|Mode" id="module.driver.sci_b_lin.mode" description="Select the LIN operating mode (master or slave).">
            <option display="Master" id="module.driver.sci_b_lin.mode.mode_master" value="LIN_MODE_MASTER" />
            <option display="Slave" id="module.driver.sci_b_lin.mode.mode_slave" value="LIN_MODE_SLAVE" />
        </property>

        <!-- LIN Extended Configuration -->
        <property default="enum.driver.sci_b.clock_source.pclk" display="Extra|Clock Source" id="module.driver.sci_b_lin.clock_source" description="Select whether the peripheral clock (PCLK) or SCICLK/SCISPICLK is used as the baud rate generator.">
            <select enum="enum.driver.sci_b.clock_source" />
        </property>
        <property default="module.driver.sci_b_lin.noisecancel_en.disabled" display="Extra|Noise Filter" id="module.driver.sci_b_lin.noisecancel_en" description="Enable the digital noise filter on RXDn pin. The digital noise filter block in SCI consists of two-stage flipflop circuits.">
            <option display="Enable" id="module.driver.sci_b_lin.noisecancel_en.enabled" value="SCI_B_LIN_NOISE_CANCELLATION_ENABLE" />
            <option display="Disable" id="module.driver.sci_b_lin.noisecancel_en.disabled" value="SCI_B_LIN_NOISE_CANCELLATION_DISABLE" />
        </property>
        <property default="module.driver.sci_b_lin.bus_conflict_detection.disabled" display="Extra|Bus Conflict Detection" id="module.driver.sci_b_lin.bus_conflict_detection" description="Enable the bus conflict detection function. When enabled, the TXDn pin output and the RXDn pin input are sampled by the bus conflict detection clock set by Extra|Bus Conflict Clock Divider. This function only works during transmission.">
            <option display="Enable" id="module.driver.sci_b_lin.bus_conflict_detection.enabled" value="SCI_B_LIN_BUS_CONFLICT_DETECTION_ENABLE" />
            <option display="Disable" id="module.driver.sci_b_lin.bus_conflict_detection.disabled" value="SCI_B_LIN_BUS_CONFLICT_DETECTION_DISABLE" />
        </property>
        <property default="module.driver.sci_b_lin.bus_conflict_clock.div_2" display="Extra|Bus Conflict Clock Divider" id="module.driver.sci_b_lin.bus_conflict_clock" description="Select the base clock divider for the sampling clock of the bus conflict detection circuit.">
            <option display="1" id="module.driver.sci_b_lin.bus_conflict_clock.div_1" value="SCI_B_LIN_BUS_CONFLICT_DETECTION_BASE_CLOCK_DIV_1" />
            <option display="2" id="module.driver.sci_b_lin.bus_conflict_clock.div_2" value="SCI_B_LIN_BUS_CONFLICT_DETECTION_BASE_CLOCK_DIV_2" />
            <option display="4" id="module.driver.sci_b_lin.bus_conflict_clock.div_4" value="SCI_B_LIN_BUS_CONFLICT_DETECTION_BASE_CLOCK_DIV_4" />
        </property>

        <!-- LIN Baud Configuration -->
        <property default="19200" display="Baud|Baud Rate" id="module.driver.sci_b_lin.baud" description="Enter the desired baud rate.\n\nIf the requested baud rate cannot be achieved, the settings with the smallest percent error are used. The theoretical calculated baud rate and percent error are printed in a comment in the generated sci_b_lin_extended_cfg_t structure.">
            <constraint display="Value must be an integer greater than 0">testInteger("${module.driver.sci_b_lin.baud}") &amp;&amp; ("${module.driver.sci_b_lin.baud}" &gt; 0) </constraint>
          <export><![CDATA[eval('' +
'/* INPUTS */' +
' var freq_hz = ${board.clock.peripheral.sciclk};' +
' if ("PCLK" === "${module.driver.sci_b_lin.clock_source}") {' +
'    freq_hz = ${board.clock.peripheral.sci_b};' +
' }' +
' var baudrate = ${module.driver.sci_b_lin.baud};' +
' var break_bits = ${module.driver.sci_b_lin.break_field_bits};' +
' var lin_divider_settings = [' +
'    { value: 4, name: "SCI_B_LIN_TIMER_DIV_4", tcss: 1 },' +
'    { value: 16, name: "SCI_B_LIN_TIMER_DIV_16", tcss: 2 },' +
'    { value: 64, name: "SCI_B_LIN_TIMER_DIV_64", tcss: 3 },' +
' ];\n' +
' var lin_divider = {};'+
' var lin_tcss = {};'+
' for (var i = 0, len = lin_divider_settings.length; i < len; i++){\n ' +
'    lin_divider = lin_divider_settings[i].value;\n' +
'    lin_tcss = lin_divider_settings[i].tcss;\n' +
'    if (lin_divider_settings[i].name === "${module.driver.sci_b_lin.timer_div}") {\n' +
'        break;' +
'     }' +
' }' +
'var lin_timer_hz = freq_hz / lin_divider; \n' +
'var bus_conflict_clock_divider_is_div_4 = ("SCI_B_LIN_BUS_CONFLICT_DETECTION_BASE_CLOCK_DIV_4" === "${module.driver.sci_b_lin.bus_conflict_clock}"); \n' +
'' +
'var lin_baud_divisors = [' +
'   /* ABCS=0, ABCS=1. In Simple LIN mode, BGDM, ABCSE, and ABCSE2 must be set to 0. */' +
'   [ 32, 16 ],' +
'   [ 128, 64 ],' +
'   [ 512, 256 ],' +
'   [ 2048, 1024]' +
'];\n' +
'' +
' /* BFLW Max */' +
' var SCI_B_LIN_BFLW_MAX = 65534; /* 16-bit counter, but 65535 is reserved.*/' +
'' +
' /* BRR Max */' +
' var SCI_B_LIN_BRR_MAX = 255;' +
''+
' /* CKS Max */' +
' var SCI_B_LIN_CKS_MAX = 3;' +
'' +
'' +
'/*******************************************************************************************************************//**' +
' * Calculates baud rate register settings based on internal clock frequency. Evaluates and determines the best possible' +
' * settings set to the baud rate related registers.' +
' *' +
' * @param[in]  freq_hz                             The source clock frequency for the SCI internal clock' +
' * @param[in]  baudrate                            Baud rate[bps] e.g. 9600, 19200, etc.' +
' *' +
' * @return  { baud_setting,                         Baud settings: {abcs, cks, brr}' +
' *           error}                                % bit rate error' +
' **********************************************************************************************************************/' +
' function r_sci_b_lin_brr_calculate(freq_hz, baudrate) {' +
'    var  divisor = 0;\n' +
'    var  brr     = 0;\n' +
'    var  abcs    = 0;\n' +
'    var  cks     = -1;\n' +
'    var result = { baud_setting: {abcs: 0, cks: 0, brr: SCI_B_LIN_BRR_MAX}, error: 100, actual_baud_rate: freq_hz/(lin_baud_divisors[0][0] * (SCI_B_LIN_BRR_MAX + 1)) };\n' +
'     ' +
'     /* BRR is calculated by testing whether each divisor (combination of ABCS, CKS, and N) produces a valid BRR setting.' +
'     * The divisors are checked in order, from smallest to largest. The smallest divisor always produces the lowest error for a given theoretical rate. ' +
'     * Try to get accurate baudrate using 16 base clk cycles per bit first (ABCS =1) before checking 8 base clock cycles per bit (ABCS = 0) (unless bus conflict ' +
'     * clock divider is 4, in which case only 8 base cycles per bit is considered. When CCR2.ABCS = 1, setting BCCS[1:0] = 1x is prohibited.) */\n' +
'    for (var i = 0; i <= SCI_B_LIN_CKS_MAX; i++)' +
'    {' +
'        cks++;' +
'        for (abcs = 1; abcs >= 0; abcs--) {' +
'            if ((abcs == 1) && (bus_conflict_clock_divider_is_div_4)) { ' +
'              /* Dont use ABCS of 1 for bus conflict divider of 4 */' +
'              continue; '+
'            }'+
'            divisor = lin_baud_divisors[cks][abcs] * baudrate;' +
'            brr     = Math.floor((freq_hz / divisor) - 1);' +
'' +
'            if (brr <= SCI_B_LIN_BRR_MAX)' +
'            {' +
'                i = (SCI_B_LIN_CKS_MAX + 1); // Break out out of outer loop\n' +
'                break;' +
'            }' +
'        }' +
'    }\n' +
'    ' +
'    /* If calculation succeeded */' +
'    if (brr <= SCI_B_LIN_BRR_MAX)\n' +
'    {' +
'        /* Calculate the error at this baud rate */' +
'        var err_divider = (divisor * (brr + 1));\n' +
'        var bit_err = Math.abs((((freq_hz * 100) / err_divider) - 100));\n' +
'     ' +
'        /* Save the best settings*/' +
'        result.baud_setting = { abcs: abcs, cks: cks, brr: brr };' +
'        result.error = bit_err;' +
'        result.actual_baud_rate = freq_hz / (lin_baud_divisors[cks][abcs] * (brr + 1));' +
'    }' +
'' +
'    return result;' +
'}' +
'/*******************************************************************************************************************//**' +
' * Calculates LIN break field width register setting based on internal clock frequency and desired break field length in bits. ' +
' * The LIN timer is used for break field detection and generation.' +
' *' +
' * @param[in]  baudrate                            Baud rate[bps] e.g. 9600, 19200, etc.' +
' * @param[in]  break_bits                          Number of dominant break field bits (eg. 9, 13, 18)' +
' *' +
' * @return  bflw_value                             Value for the LIN timer BFLW setting' +
' **********************************************************************************************************************/' +
'function r_sci_b_lin_bflw_calculate(baudrate, break_bits) {\n' +
'  var bflw_setting = Math.floor((lin_timer_hz * break_bits)/baudrate) - 1;     \n' +
'  if (bflw_setting > SCI_B_LIN_BFLW_MAX) {       ' +
'      bflw_setting = SCI_B_LIN_BFLW_MAX;  \n' +
'  }   \n' +
'  return bflw_setting; \n' +
'}' +
'' +
''+
' /* Calculate baud rate register settings */'+
'  var baud_result = r_sci_b_lin_brr_calculate(freq_hz, baudrate);'+
''+
' /* Compute BFLW settings at this baud rate */' +
' var bflw_result = r_sci_b_lin_bflw_calculate(baudrate, break_bits);' +
'' +
' /* Build the text to populate the C baud setting structure */\n' +
' var c_baud_setting = "/* Actual calculated baud rate: " + baud_result.actual_baud_rate.toFixed(0) + " (" + baud_result.error.toFixed(3) + "% error) */" +' +
'    " .baudrate_bits_b = { .abcs = " + baud_result.baud_setting.abcs.toString() +' +
'    ", .cks = " + baud_result.baud_setting.cks.toString() +' +
'    ", .brr = " + baud_result.baud_setting.brr.toString() +' +
'    "}, .timer_setting = { .tcss = " + "${module.driver.sci_b_lin.timer_div}" +' +
'    ", .bflw = " + bflw_result.toString() + "}";' +
''+
' /* Output the C baud setting structure setting */\n' +
' c_baud_setting' +
'')
]]>            </export>
        </property>
        <property default="module.driver.sci_b_lin.auto_synchronization.disabled" display="Baud|Auto Synchronization" id="module.driver.sci_b_lin.auto_synchronization" description="Enable LIN synchronization to the master's clock by measuring the effective edges of the input signal from the RXDn pin during reception of the sync byte.">
            <option display="Disable" id="module.driver.sci_b_lin.auto_synchronization.disabled" value="SCI_B_LIN_AUTO_SYNCHRONIZATION_DISABLE" />
            <option display="Enable" id="module.driver.sci_b_lin.auto_synchronization.enabled" value="SCI_B_LIN_AUTO_SYNCHRONIZATION_ENABLE" />
        </property>

        <!-- LIN Framing Configuration -->
        <property default="13" display="Framing|Break Field Bits/Break Detection Threshold (bits)"
            id="module.driver.sci_b_lin.break_field_bits"
            description="For master break field transmission, this configures the dominant period of the break field (in bits). For slave break field reception, this configures the break detection threshold in bits. Must be 13 bits or greater for master mode and 11 bits or greater for slave mode.">
            <constraint display="Value must be an integer.">
                testInteger("${module.driver.sci_b_lin.break_field_bits}")
            </constraint>
        </property>
        <property default="module.driver.sci_b_lin.timer_div.div_4" display="Framing|LIN Timer Divider"
            id="module.driver.sci_b_lin.timer_div"
            description="Set the LIN timer divider. The LIN timer is used for break field transmission and detection. Higher dividers make possible transmission/detection of more break field bits, but are less precise.">
                <option display="4" id="module.driver.sci_b_lin.timer_div.div_4" value="SCI_B_LIN_TIMER_DIV_4" />
                <option display="16" id="module.driver.sci_b_lin.timer_div.div_16" value="SCI_B_LIN_TIMER_DIV_16" />
                <option display="64" id="module.driver.sci_b_lin.timer_div.div_64" value="SCI_B_LIN_TIMER_DIV_64" />
        </property>
        <property default="module.driver.sci_b_lin.delimiter_bits.delimiter_bits_1" display="Framing|Break Field Delimiter/Stop Bits" id="module.driver.sci_b_lin.delimiter_bits" description="Select the recessive period (in bits) of the break field. This setting also selects the number of stop bits.">
            <option display="1bit" id="module.driver.sci_b_lin.delimiter_bits.delimiter_bits_1" value="SCI_B_LIN_BREAK_DELIMITER_BITS_1" />
            <option display="2bits" id="module.driver.sci_b_lin.delimiter_bits.delimiter_bits_2" value="SCI_B_LIN_BREAK_DELIMITER_BITS_2" />
        </property>
        <property default="0" display="Framing|ID Filter (Slave Mode)|Compare Data Mask" id="module.driver.sci_b_lin.compare_data_mask" description="Select the bit mask to be applied before comparing the received PID to the selected compare data. This setting specifies which bits of the selected compare data must match. Set to 0 to disable the filter (allow all frame identifiers). ">
            <constraint display="Value must be an integer between 0 and 255.">
                (testInteger("${module.driver.sci_b_lin.compare_data_mask}") &amp;&amp; ("${module.driver.sci_b_lin.compare_data_mask}" &gt;= 0) &amp;&amp; ("${module.driver.sci_b_lin.compare_data_mask}" &lt;= 255))
            </constraint>
        </property>
        <property default="0" display="Framing|ID Filter (Slave Mode)|Priority Compare Data" id="module.driver.sci_b_lin.priority_compare_data" description="Select the priority compare filter data.">
            <constraint display="Value must be an integer between 0 and 255.">
                (testInteger("${module.driver.sci_b_lin.priority_compare_data}") &amp;&amp; ("${module.driver.sci_b_lin.priority_compare_data}" &gt;= 0) &amp;&amp; ("${module.driver.sci_b_lin.priority_compare_data}" &lt;= 255))
            </constraint>
        </property>
        <property default="0" display="Framing|ID Filter (Slave Mode)|Secondary Compare Data" id="module.driver.sci_b_lin.secondary_compare_data" description="Select the secondary compare filter data.">
            <constraint display="Value must be an integer between 0 and 255.">
                (testInteger("${module.driver.sci_b_lin.secondary_compare_data}") &amp;&amp; ("${module.driver.sci_b_lin.secondary_compare_data}" &gt;= 0) &amp;&amp; ("${module.driver.sci_b_lin.secondary_compare_data}" &lt;= 255))
            </constraint>
        </property>
        <property default="module.driver.sci_b_lin.compare_data_select.priority" display="Framing|ID Filter (Slave Mode)|Compare Data Select" id="module.driver.sci_b_lin.compare_data_select" description="Select the compare data to use. If 'both' is selected, the priority compare data is checked before the secondary compare data.">
                <option display="Priority" id="module.driver.sci_b_lin.compare_data_select.priority" value="SCI_B_LIN_COMPARE_DATA_SELECT_PRIORITY" />
                <option display="Secondary" id="module.driver.sci_b_lin.compare_data_select.secondary" value="SCI_B_LIN_COMPARE_DATA_SELECT_SECONDARY" />
                <option display="Both" id="module.driver.sci_b_lin.compare_data_select.both" value="SCI_B_LIN_COMPARE_DATA_SELECT_BOTH" />
        </property>
        <property default="module.driver.sci_b_lin.priority_interrupt_enable.disabled" display="Framing|ID Filter (Slave Mode)|Priority Interrupt Bit Enable" id="module.driver.sci_b_lin.priority_interrupt_enable" description="Select whether to enable the Priority Interrupt Bit filter. When enabled, regardless of the Filter Data Select setting value, the bit specified by the Priority Interrupt Bit setting is compared with the corresponding bit in the Priority Compare Data Filter and if it matches, the identifier is allowed through the filter.">
            <option display="Enabled" id="module.driver.sci_b_lin.priority_interrupt_enable.enabled" value="SCI_B_LIN_PRIORITY_INTERRUPT_BIT_ENABLE" />
            <option display="Disabled" id="module.driver.sci_b_lin.priority_interrupt_enable.disabled" value="SCI_B_LIN_PRIORITY_INTERRUPT_BIT_DISABLE" />
        </property>
        <property default="0" display="Framing|ID Filter (Slave Mode)|Priority Interrupt Bit" id="module.driver.sci_b_lin.priority_interrupt_bit_select" description="Select the priority interrupt bit (0-7) of the received PID to compare with the corresponding bit in the Priority Compare Data Filter.  ">
            <constraint display="Value must be an integer between bit 0 (LSb) and bit 7 (MSb).">
                (testInteger("${module.driver.sci_b_lin.priority_interrupt_bit_select}") &amp;&amp; ("${module.driver.sci_b_lin.priority_interrupt_bit_select}" &gt;= 0) &amp;&amp; ("${module.driver.sci_b_lin.priority_interrupt_bit_select}" &lt;= 7))
            </constraint>
        </property>
        <!-- LIN Interrupts Configuration -->
        <property default="sci_b_lin${_instance}_callback" display="Interrupts|Callback" id="module.driver.sci_b_lin.callback" description="A user callback function must be provided. It will be called from the interrupt service routine (ISR).">
            <constraint display="Name must be a valid C symbol">
                testSymbol("${module.driver.sci_b_lin.callback}")
            </constraint>
        </property>
        <property default="" display="Interrupts|Receive Interrupt Priority" id="module.driver.sci_b_lin.rxi_ipl" description="Select the receive interrupt priority.">
            <select enum="enum.mcu.nvic.priorities.mandatory" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.rxi" isr="sci_b_lin_rxi_isr" />
        </property>
        <property default="" display="Interrupts|Transmit Data Empty Interrupt Priority" id="module.driver.sci_b_lin.txi_ipl" description="Select the transmit interrupt priority.">
            <select enum="enum.mcu.nvic.priorities.mandatory" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.txi" isr="sci_b_lin_txi_isr" />
        </property>
        <property default="" display="Interrupts|Transmit End Interrupt Priority" id="module.driver.sci_b_lin.tei_ipl" description="Select the transmit end interrupt priority.">
            <select enum="enum.mcu.nvic.priorities.mandatory" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.tei" isr="sci_b_lin_tei_isr" />
        </property>
        <property default="" display="Interrupts|Error Interrupt Priority" id="module.driver.sci_b_lin.eri_ipl" description="Select the error interrupt priority.">
            <select enum="enum.mcu.nvic.priorities.mandatory" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.eri" isr="sci_b_lin_eri_isr" />
        </property>
        <property default="" display="Interrupts|Break Field Detection Interrupt Priority" id="module.driver.sci_b_lin.bfd_ipl" description="Select the break field detection interrupt priority (slave mode only).">
            <select enum="enum.mcu.nvic.priorities.optional" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.bfd" isr="sci_b_lin_bfd_isr" />
        </property>
        <property default="" display="Interrupts|Active Edge Detection Interrupt Priority" id="module.driver.sci_b_lin.aed_ipl" description="Select the active edge detection interrupt priority.">
            <select enum="enum.mcu.nvic.priorities.optional" />
            <interrupt event="event.sci${module.driver.sci_b_lin.channel}.aed" isr="sci_b_lin_aed_isr" />
        </property>

        <!-- LIN Pin Configurations -->
        <peripheral name="SCI${module.driver.sci_b_lin.channel}" component="sci${module.driver.sci_b_lin.channel}" pin="sci${module.driver.sci_b_lin.channel}.rxd${module.driver.sci_b_lin.channel}" />
        <peripheral name="SCI${module.driver.sci_b_lin.channel}" component="sci${module.driver.sci_b_lin.channel}" pin="sci${module.driver.sci_b_lin.channel}.txd${module.driver.sci_b_lin.channel}" />

        <symbol id="symbol.driver.sci_b_lin.name" value="${module.driver.sci_b_lin.name}"/>
        <symbol id="symbol.driver.sci_b_lin.guard.open" value="${module.driver.sci_b_lin.name}_open_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.open" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_Open"/>
        <symbol id="symbol.driver.sci_b_lin.guard.start_frame_write" value="${module.driver.sci_b_lin.name}_start_frame_write_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.start_frame_write" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_StartFrameWrite"/>
        <symbol id="symbol.driver.sci_b_lin.guard.information_frame_write" value="${module.driver.sci_b_lin.name}_information_frame_write_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.information_frame_write" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_InformationFrameWrite"/>
        <symbol id="symbol.driver.sci_b_lin.guard.information_frame_read" value="${module.driver.sci_b_lin.name}_information_frame_read_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.information_frame_read" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_InformationFrameRead"/>
        <symbol id="symbol.driver.sci_b_lin.guard.communication_abort" value="${module.driver.sci_b_lin.name}_communication_abort_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.communication_abort" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_CommunicationAbort"/>
        <symbol id="symbol.driver.sci_b_lin.guard.callback_set" value="${module.driver.sci_b_lin.name}_callback_set_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.callback_set" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_CallbackSet"/>
        <symbol id="symbol.driver.sci_b_lin.guard.id_filter_set" value="${module.driver.sci_b_lin.name}_id_filter_set_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.id_filter_set" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_IdFilterSet"/>
        <symbol id="symbol.driver.sci_b_lin.guard.id_filter_get" value="${module.driver.sci_b_lin.name}_id_filter_get_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.id_filter_get" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_IdFilterGet"/>
        <symbol id="symbol.driver.sci_b_lin.guard.close" value="${module.driver.sci_b_lin.name}_close_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.close" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_Close"/>
        <symbol id="symbol.driver.sci_b_lin.guard.baud_calculate" value="${module.driver.sci_b_lin.name}_baud_calculate_guard"/>
        <symbol id="symbol.driver.sci_b_lin.guard.macro.baud_calculate" value="FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_BaudCalculate"/>
        <symbol id="symbol.driver.sci_b_lin.nsc_api" value="${module.driver.sci_b_lin.name}_nsc_api"/>
        <symbol id="symbol.driver.sci_b_lin.cfg" value="${module.driver.sci_b_lin.name}_cfg"/>
        <symbol id="symbol.driver.sci_b_lin.cfg_extend" value="${module.driver.sci_b_lin.name}_cfg_extend"/>
        <symbol id="symbol.driver.sci_b_lin.ctrl" value="${module.driver.sci_b_lin.name}_ctrl"/>
        <header>
            /** LIN on SCI B Instance. */
            extern const lin_instance_t ${module.driver.sci_b_lin.name};

            /** Access the LIN instance using these structures when calling API functions directly
            (::p_api is not used). */
            extern sci_b_lin_instance_ctrl_t ${module.driver.sci_b_lin.name}_ctrl;
            extern const lin_cfg_t ${module.driver.sci_b_lin.name}_cfg;
            extern const sci_b_lin_extended_cfg_t ${module.driver.sci_b_lin.name}_cfg_extend;

#ifndef ${module.driver.sci_b_lin.callback}
            void ${module.driver.sci_b_lin.callback}(lin_callback_args_t * p_args);
#endif
        </header>
        <includes>
            #include &quot;r_sci_b_lin.h&quot;
            #include &quot;r_lin_api.h&quot;
        </includes>
        <declarations>
            sci_b_lin_instance_ctrl_t ${module.driver.sci_b_lin.name}_ctrl;

            /** LIN extended configuration for LIN on SCI B HAL driver */
            const sci_b_lin_extended_cfg_t ${module.driver.sci_b_lin.name}_cfg_extend =
            {
                .sci_b_settings =
                    ((SCI_B_LIN_CLOCK_SOURCE_${module.driver.sci_b_lin.clock_source} &lt;&lt; 0U) |
                    (${module.driver.sci_b_lin.noisecancel_en} &lt;&lt; 1U) |
                    (${module.driver.sci_b_lin.delimiter_bits} &lt;&lt; 2U) |
                    (${module.driver.sci_b_lin.bus_conflict_detection} &lt;&lt; 3U) |
                    (${module.driver.sci_b_lin.bus_conflict_clock} &lt;&lt; 4U) |
                    (${module.driver.sci_b_lin.auto_synchronization} &lt;&lt; 6U)),
                .baud_setting = {
                   ${module.driver.sci_b_lin.baud},
                 },
                .bfd_ipl = ${module.driver.sci_b_lin.bfd_ipl},
                .aed_ipl =  ${module.driver.sci_b_lin.aed_ipl},
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_BFD)
                .bfd_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_BFD,
#else
                .bfd_irq = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_AED)
                .aed_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_AED,
#else
                .aed_irq = FSP_INVALID_VECTOR,
#endif
                .break_bits = ${module.driver.sci_b_lin.break_field_bits},
                .filter_setting = {
                    .compare_data_mask = ${module.driver.sci_b_lin.compare_data_mask},
                    .priority_compare_data = ${module.driver.sci_b_lin.priority_compare_data},
                    .secondary_compare_data = ${module.driver.sci_b_lin.secondary_compare_data},
                    .priority_interrupt_bit_select = ${module.driver.sci_b_lin.priority_interrupt_bit_select},
                    .priority_interrupt_enable = ${module.driver.sci_b_lin.priority_interrupt_enable},
                    .compare_data_select = ${module.driver.sci_b_lin.compare_data_select},
                }
            };

            /** LIN interface configuration */
            const lin_cfg_t ${module.driver.sci_b_lin.name}_cfg =
            {
                .channel = ${module.driver.sci_b_lin.channel},
                .mode = ${module.driver.sci_b_lin.mode},
                .p_callback = ${module.driver.sci_b_lin.callback},
                .p_context = NULL,
                .p_extend = &amp;${module.driver.sci_b_lin.name}_cfg_extend,
                .rxi_ipl = ${module.driver.sci_b_lin.rxi_ipl},
                .txi_ipl = ${module.driver.sci_b_lin.txi_ipl},
                .tei_ipl = ${module.driver.sci_b_lin.tei_ipl},
                .eri_ipl = ${module.driver.sci_b_lin.eri_ipl},
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_RXI)
                .rxi_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_RXI,
#else
                .rxi_irq = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_TXI)
                .txi_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_TXI,
#else
                .txi_irq = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_TEI)
                .tei_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_TEI,
#else
                .tei_irq = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_ERI)
                .eri_irq = VECTOR_NUMBER_SCI${module.driver.sci_b_lin.channel}_ERI,
#else
                .eri_irq = FSP_INVALID_VECTOR,
#endif
            };

            /* Instance structure to use this module. */
            const lin_instance_t ${module.driver.sci_b_lin.name} =
            {
                .p_ctrl = &amp;${module.driver.sci_b_lin.name}_ctrl,
                .p_cfg = &amp;${module.driver.sci_b_lin.name}_cfg,
                .p_api = &amp;g_lin_on_sci_b
            };
        </declarations>
        <guard>
            <header>

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_open_guard(lin_ctrl_t *const p_api_ctrl, lin_cfg_t const *const p_cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_start_frame_write_guard(lin_ctrl_t *const p_api_ctrl, uint8_t const id);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_write_guard(lin_ctrl_t *const p_api_ctrl, const lin_transfer_params_t *const p_transfer_params);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_read_guard(lin_ctrl_t *const p_api_ctrl, lin_transfer_params_t *const p_transfer_params);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_communication_abort_guard(lin_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_callback_set_guard(lin_ctrl_t *const p_api_ctrl, void(*p_callback)(lin_callback_args_t *), void const *const p_context, lin_callback_args_t *const p_callback_memory);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_set_guard(lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t const *const p_config);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_get_guard(lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t *const p_config);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_close_guard(lin_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_baud_calculate_guard(sci_b_lin_baud_params_t const *const p_baud_params, sci_b_lin_baud_setting_t *const p_baud_setting);

            </header>
            <template name="${module.driver.sci_b_lin.name}_guard.c">
                <![CDATA[
                    #include "guard.h"


BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_open_guard (lin_ctrl_t *const p_api_ctrl, lin_cfg_t const *const p_cfg)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(p_cfg);

    return R_SCI_B_LIN_Open(&${module.driver.sci_b_lin.name}_ctrl, &${module.driver.sci_b_lin.name}_cfg);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_start_frame_write_guard (lin_ctrl_t *const p_api_ctrl, uint8_t const id)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_StartFrameWrite(&${module.driver.sci_b_lin.name}_ctrl, id);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_write_guard (lin_ctrl_t *const p_api_ctrl, const lin_transfer_params_t *const p_transfer_params)
{
    /* Verify all pointers are in non-secure memory. */
    const lin_transfer_params_t *const p_transfer_params_checked = cmse_check_pointed_object(( lin_transfer_params_t *) p_transfer_params, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_transfer_params_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_InformationFrameWrite(&${module.driver.sci_b_lin.name}_ctrl, p_transfer_params_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_read_guard (lin_ctrl_t *const p_api_ctrl, lin_transfer_params_t *const p_transfer_params)
{
    /* Verify all pointers are in non-secure memory. */
    lin_transfer_params_t *const p_transfer_params_checked = cmse_check_pointed_object(p_transfer_params, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_transfer_params_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_InformationFrameRead(&${module.driver.sci_b_lin.name}_ctrl, p_transfer_params_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_communication_abort_guard (lin_ctrl_t *const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_CommunicationAbort(&${module.driver.sci_b_lin.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_callback_set_guard (lin_ctrl_t *const p_api_ctrl, void(*p_callback)(lin_callback_args_t *), void const *const p_context, lin_callback_args_t *const p_callback_memory)
{
    /* Verify all pointers are in non-secure memory. */
    void(*p_callback_checked)(lin_callback_args_t *) = (void(*)(lin_callback_args_t *)) cmse_check_address_range((void *) p_callback, sizeof(void *), CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_checked != NULL);
    lin_callback_args_t *const p_callback_memory_checked = cmse_check_pointed_object(p_callback_memory, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_memory_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(p_context);

    return R_SCI_B_LIN_CallbackSet(&${module.driver.sci_b_lin.name}_ctrl, p_callback_checked, p_context, p_callback_memory_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_set_guard (lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t const *const p_config)
{
    /* Verify all pointers are in non-secure memory. */
    sci_b_lin_id_filter_setting_t const *const p_config_checked = cmse_check_pointed_object((sci_b_lin_id_filter_setting_t *) p_config, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_config_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_IdFilterSet(&${module.driver.sci_b_lin.name}_ctrl, p_config_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_get_guard (lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t *const p_config)
{
    /* Verify all pointers are in non-secure memory. */
    sci_b_lin_id_filter_setting_t *const p_config_checked = cmse_check_pointed_object(p_config, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_config_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_IdFilterGet(&${module.driver.sci_b_lin.name}_ctrl, p_config_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_close_guard (lin_ctrl_t *const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SCI_B_LIN_Close(&${module.driver.sci_b_lin.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_baud_calculate_guard (sci_b_lin_baud_params_t const *const p_baud_params, sci_b_lin_baud_setting_t *const p_baud_setting)
{
    /* Verify all pointers are in non-secure memory. */
    sci_b_lin_baud_params_t const *const p_baud_params_checked = cmse_check_pointed_object((sci_b_lin_baud_params_t *) p_baud_params, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_baud_params_checked != NULL);
    sci_b_lin_baud_setting_t *const p_baud_setting_checked = cmse_check_pointed_object(p_baud_setting, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_baud_setting_checked != NULL);

    /* TODO: add your own security checks here */

    return R_SCI_B_LIN_BaudCalculate(p_baud_params_checked, p_baud_setting_checked);
}

                ]]>
            </template>
        </guard>
        <nsc>
            <header>

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_Open() ${module.driver.sci_b_lin.name}_open_guard(FSP_SECURE_ARGUMENT, FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_StartFrameWrite(id) ${module.driver.sci_b_lin.name}_start_frame_write_guard(FSP_SECURE_ARGUMENT, id)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_InformationFrameWrite(p_transfer_params) ${module.driver.sci_b_lin.name}_information_frame_write_guard(FSP_SECURE_ARGUMENT, p_transfer_params)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_InformationFrameRead(p_transfer_params) ${module.driver.sci_b_lin.name}_information_frame_read_guard(FSP_SECURE_ARGUMENT, p_transfer_params)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_CommunicationAbort() ${module.driver.sci_b_lin.name}_communication_abort_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_CallbackSet(p_callback, p_context, p_callback_memory) ${module.driver.sci_b_lin.name}_callback_set_guard(FSP_SECURE_ARGUMENT, p_callback, p_context, p_callback_memory)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_IdFilterSet(p_config) ${module.driver.sci_b_lin.name}_id_filter_set_guard(FSP_SECURE_ARGUMENT, p_config)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_IdFilterGet(p_config) ${module.driver.sci_b_lin.name}_id_filter_get_guard(FSP_SECURE_ARGUMENT, p_config)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_Close() ${module.driver.sci_b_lin.name}_close_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.sci_b_lin.name}_R_SCI_B_LIN_BaudCalculate(p_baud_params, p_baud_setting) ${module.driver.sci_b_lin.name}_baud_calculate_guard(p_baud_params, p_baud_setting)



BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_open_guard(lin_ctrl_t *const p_api_ctrl, lin_cfg_t const *const p_cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_start_frame_write_guard(lin_ctrl_t *const p_api_ctrl, uint8_t const id);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_write_guard(lin_ctrl_t *const p_api_ctrl, const lin_transfer_params_t *const p_transfer_params);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_information_frame_read_guard(lin_ctrl_t *const p_api_ctrl, lin_transfer_params_t *const p_transfer_params);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_communication_abort_guard(lin_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_callback_set_guard(lin_ctrl_t *const p_api_ctrl, void(*p_callback)(lin_callback_args_t *), void const *const p_context, lin_callback_args_t *const p_callback_memory);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_set_guard(lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t const *const p_config);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_id_filter_get_guard(lin_ctrl_t *const p_api_ctrl, sci_b_lin_id_filter_setting_t *const p_config);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_close_guard(lin_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.sci_b_lin.name}_baud_calculate_guard(sci_b_lin_baud_params_t const *const p_baud_params, sci_b_lin_baud_setting_t *const p_baud_setting);


extern const lin_instance_t ${module.driver.sci_b_lin.name};
            </header>
            <declarations>
                <![CDATA[
static const lin_api_t ${module.driver.sci_b_lin.name}_nsc_api =
{
    .open = ${module.driver.sci_b_lin.name}_open_guard,
    .startFrameWrite = ${module.driver.sci_b_lin.name}_start_frame_write_guard,
    .informationFrameWrite = ${module.driver.sci_b_lin.name}_information_frame_write_guard,
    .informationFrameRead = ${module.driver.sci_b_lin.name}_information_frame_read_guard,
    .communicationAbort = ${module.driver.sci_b_lin.name}_communication_abort_guard,
    .callbackSet = ${module.driver.sci_b_lin.name}_callback_set_guard,
    .close = ${module.driver.sci_b_lin.name}_close_guard,
};
const lin_instance_t ${module.driver.sci_b_lin.name} =
{
    .p_api = &${module.driver.sci_b_lin.name}_nsc_api,
    .p_ctrl = FSP_SECURE_ARGUMENT,
    .p_cfg = FSP_SECURE_ARGUMENT,
};
                ]]>
            </declarations>
        </nsc>
        <api configurable="true">
            <file>ra/fsp/inc/instances/r_sci_b_lin.h</file>
            <file>ra/fsp/inc/api/r_lin_api.h</file>
        </api>
    </module>
</raModuleDescription>
