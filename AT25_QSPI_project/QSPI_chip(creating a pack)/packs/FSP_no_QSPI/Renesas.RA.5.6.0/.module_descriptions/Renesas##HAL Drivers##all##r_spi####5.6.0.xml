<?xml version="1.0" ?>
<raModuleDescription>
    <config id="config.driver.spi" path="fsp_cfg/r_spi_cfg.h" version="0">
        <property default="config.driver.spi.param_checking_enable.bsp" display="Parameter Checking" id="config.driver.spi.param_checking_enable" description="If selected code for parameter checking is included in the build.">
            <option display="Default (BSP)" id="config.driver.spi.param_checking_enable.bsp" value="(BSP_CFG_PARAM_CHECKING_ENABLE)"/>
            <option display="Enabled" id="config.driver.spi.param_checking_enable.enabled" value="(1)"/>
            <option display="Disabled" id="config.driver.spi.param_checking_enable.disabled" value="(0)"/>
        </property>
        <!-- This property's id should be renamed in the future to make it clear it refers to transfer support, not just dtc support. -->
        <property default="config.driver.spi.dtc_enable.enabled" display="Enable Support for using a transfer API" id="config.driver.spi.dtc_enable" description="If enabled, transfer instances will be included in the build for both transmission and reception.">
            <option display="Enabled" id="config.driver.spi.dtc_enable.enabled" value="(1)"/>
            <option display="Disabled" id="config.driver.spi.dtc_enable.disabled" value="(0)"/>
        </property>
        <property default="config.driver.spi.rxi_transmit.disabled" display="Enable Transmitting from RXI Interrupt" id="config.driver.spi.rxi_transmit" description="If enabled, all operations will be handled from the RX (receive) interrupt. This setting only provides a performance boost when neither DTC nor DMAC is used. In addition, Transmit Only mode is not supported when this configuration is enabled.">
            <option display="Enabled" id="config.driver.spi.rxi_transmit.enabled" value="(1)"/>
            <option display="Disabled" id="config.driver.spi.rxi_transmit.disabled" value="(0)"/>
        </property>
        <content>
        #ifdef __cplusplus
        extern "C" {
        #endif

        #define SPI_CFG_PARAM_CHECKING_ENABLE ${config.driver.spi.param_checking_enable}
        #define SPI_DMA_SUPPORT_ENABLE ${config.driver.spi.dtc_enable}
        #define SPI_TRANSMIT_FROM_RXI_ISR ${config.driver.spi.rxi_transmit}

        #ifdef __cplusplus
        }
        #endif
        </content>
    </config>
    <module config="config.driver.spi" display="Connectivity|${module.driver.spi.name} SPI (r_spi)" id="module.driver.spi_on_spi" version="1" url="group___s_p_i.html">
        <constraint display="Unique name required for each instance">
            "${interface.driver.spi.${module.driver.spi.name}}" === "1"
        </constraint>
        <constraint display="Channel not available on selected MCU">
            "${interface.mcu.spi.${module.driver.spi.channel}}" === "1"
        </constraint>
        <constraint display="Requires SPI Peripheral">
          "${interface.mcu.spi.external}" === "1"
        </constraint>
        <constraint display="Transfer support must be enabled to use a transfer API">
            "${config.driver.spi.dtc_enable}" === "config.driver.spi.dtc_enable.enabled" ||
            ((!testExists("${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}")) &amp;&amp;
             (!testExists("${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}")))
        </constraint>
        <constraint display="When DMAC is used, Transfer End Interrupt must be enabled in the Transfer (r_dmac) module">
            (("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" != "1") ||
            ("${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.ipl}" != "_disabled")) &amp;&amp;
            (("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" != "1") ||
            ("${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.ipl}" != "_disabled"))
        </constraint>
        <constraint display="When DMAC is used for receiving, RXI interrupt must be disabled">
            ("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" != "1") ||
            ("${module.driver.spi.rxi_ipl}" == "_disabled")
        </constraint>
        <constraint display="When DMAC is not used for receiving, RXI interrupt must be enabled">
            ("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" === "1") ||
            ("${module.driver.spi.rxi_ipl}" != "_disabled")
        </constraint>
        <constraint display="When DMAC is used for transmitting, TXI interrupt must be disabled">
            ("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" != "1") ||
            ("${module.driver.spi.txi_ipl}" == "_disabled")
        </constraint>
        <constraint display="When DMAC is not used for transmitting, TXI interrupt must be enabled">
            ("${interface.driver.transfer_on_dmac.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" === "1") ||
            ("${module.driver.spi.txi_ipl}" != "_disabled")
        </constraint>
        <constraint display="Requires transfer instance for both or neither when SPI_TRANSMIT_FROM_RXI_ISR is enabled">
            (("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" === "1") &amp;&amp;
            ("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" === "1")) ||
            (("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" != "1") &amp;&amp;
            ("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" != "1")) ||
            ("${config.driver.spi.rxi_transmit}" === "config.driver.spi.rxi_transmit.disabled")
        </constraint>
        <constraint display="Transmit Only Mode is not supported when transmitting from rxi interrupt.">
            (("${config.driver.spi.rxi_transmit}" === "config.driver.spi.rxi_transmit.enabled") &amp;&amp; ("${module.driver.spi.spi_comm}" === "module.driver.spi.spi_comm.full_duplex")) || ("${config.driver.spi.rxi_transmit}" === "config.driver.spi.rxi_transmit.disabled")
        </constraint>
        <constraint display="Specified 'Bitrate' is not available on selected MCU.">
            (testInteger("${module.driver.spi.bitrate}") &amp;&amp; ("${module.driver.spi.bitrate}" &gt; 0) &amp;&amp; ("${module.driver.spi.bitrate}" &lt;= (Number("${config.bsp.fsp.mcu.spi.max_bitrate}"))))
        </constraint>
        <constraint display="Transfer sizes must be the same">
            ((!(("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name}}" === "1") &amp;&amp; ("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name}}" === "1"))) || ("${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.size}}" === "${interface.driver.transfer.${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.size}}"))
        </constraint>
        <constraint display="Only SSL0 is configurable when Operating Mode is Slave">
            (!(("${module.driver.spi.operating_mode}" === "module.driver.spi.operating_mode.mode_slave") &amp;&amp; ("${module.driver.spi.ssl_select}" != "module.driver.spi.ssl_select.zero")))
        </constraint>
        <requires id="module.driver.spi_on_spi.requires.spi" interface="interface.mcu.spi.external" visible="false" display="Requires SPI Peripheral" />
        <requires id="module.driver.spi_on_spi.requires.transfer_tx" interface="interface.driver.transfer" display="Add Transfer Driver for Transmission [Recommended but optional]" optional="true" >
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_normal"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.activation_source" value="_signal.event.spi${module.driver.spi.channel}.txi"/>
            <override property="module.driver.transfer.activation_event" value="_signal.event.spi${module.driver.spi.channel}.txi"/>
            <override property="module.driver.transfer.p_callback" value="${module.driver.spi.name}_tx_transfer_callback"/>
        </requires>
        <requires id="module.driver.spi_on_spi.requires.transfer_rx" interface="interface.driver.transfer" display="Add Transfer Driver for Reception [Recommended but optional]" optional="true" >
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_normal"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.activation_source" value="_signal.event.spi${module.driver.spi.channel}.rxi"/>
            <override property="module.driver.transfer.activation_event" value="_signal.event.spi${module.driver.spi.channel}.rxi"/>
            <override property="module.driver.transfer.p_callback" value="${module.driver.spi.name}_rx_transfer_callback"/>
        </requires>
        <provides interface="interface.driver.spi" />
        <provides interface="interface.driver.spi_on_spi" />
        <provides interface="interface.driver.spi.${module.driver.spi.name}" />
        <provides interface="interface.peripheral.spi${module.driver.spi.channel}" />
        <property default="spi" id="module.driver.spi.spi_interface" description=""/>
        <property default="g_spi${_instance}" display="Name" id="module.driver.spi.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.driver.spi.name}")</constraint>
        </property>

        <!-- SPI configuration -->
        <property default="0" display="Channel" id="module.driver.spi.channel" description="Select the SPI channel.">
            <constraint display="Value must be a non-negative integer">testInteger("${module.driver.spi.channel}")  &amp;&amp; ("${module.driver.spi.channel}" &gt;= 0)</constraint>
            <signal event="event.spi${module.driver.spi.channel}.eri" />
            <signal event="event.spi${module.driver.spi.channel}.idle" />
            <signal event="event.spi${module.driver.spi.channel}.rxi" />
            <signal event="event.spi${module.driver.spi.channel}.txi" />
            <signal event="event.spi${module.driver.spi.channel}.tei" />
        </property>
        <property default="" display="Receive Interrupt Priority" id="module.driver.spi.rxi_ipl" description="Select the interrupt priority for all SPI interrupts.">
            <select enum="enum.mcu.nvic.priorities.optional"/>
            <interrupt event="event.spi${module.driver.spi.channel}.rxi" isr="spi_rxi_isr"/>
        </property>
        <property default="" display="Transmit Buffer Empty Interrupt Priority" id="module.driver.spi.txi_ipl" description="Select the interrupt priority for all SPI interrupts.">
            <select enum="enum.mcu.nvic.priorities.optional"/>
            <interrupt event="event.spi${module.driver.spi.channel}.txi" isr="spi_txi_isr"/>
        </property>
        <property default="" display="Transfer Complete Interrupt Priority" id="module.driver.spi.tei_ipl" description="Select the interrupt priority for all SPI interrupts.">
            <select enum="enum.mcu.nvic.priorities.mandatory"/>
            <interrupt event="event.spi${module.driver.spi.channel}.tei" isr="spi_tei_isr"/>
        </property>
        <property default="" display="Error Interrupt Priority" id="module.driver.spi.eri_ipl" description="Select the interrupt priority for all SPI interrupts.">
            <select enum="enum.mcu.nvic.priorities.mandatory"/>
            <interrupt event="event.spi${module.driver.spi.channel}.eri" isr="spi_eri_isr"/>
        </property>
        <property default="module.driver.spi.operating_mode.mode_master" display="Operating Mode" id="module.driver.spi.operating_mode" description="Select the SPI operating mode.">
            <option display="Master" id="module.driver.spi.operating_mode.mode_master" value="SPI_MODE_MASTER"/>
            <option display="Slave" id="module.driver.spi.operating_mode.mode_slave" value="SPI_MODE_SLAVE"/>
        </property>
        <property default="module.driver.spi.clk_phase.clk_phase_edge_odd" display="Clock Phase" id="module.driver.spi.clk_phase" description="Select the clock edge to sample data.">
            <option display="Data sampling on odd edge, data variation on even edge" id="module.driver.spi.clk_phase.clk_phase_edge_odd" value="SPI_CLK_PHASE_EDGE_ODD"/>
            <option display="Data sampling on even edge, data variation on odd edge" id="module.driver.spi.clk_phase.clk_phase_edge_even" value="SPI_CLK_PHASE_EDGE_EVEN"/>
        </property>
        <property default="module.driver.spi.clk_polarity.clk_polarity_low" display="Clock Polarity" id="module.driver.spi.clk_polarity" description="Select clock level when idle.">
            <option display="Low when idle" id="module.driver.spi.clk_polarity.clk_polarity_low" value="SPI_CLK_POLARITY_LOW"/>
            <option display="High when idle" id="module.driver.spi.clk_polarity.clk_polarity_high" value="SPI_CLK_POLARITY_HIGH"/>
        </property>
        <property default="module.driver.spi.mode_fault.mode_fault_error_disable" display="Mode Fault Error" id="module.driver.spi.mode_fault" description="Detect master/slave mode conflicts.">
            <option display="Enable" id="module.driver.spi.mode_fault.mode_fault_error_enable" value="SPI_MODE_FAULT_ERROR_ENABLE"/>
            <option display="Disable" id="module.driver.spi.mode_fault.mode_fault_error_disable" value="SPI_MODE_FAULT_ERROR_DISABLE"/>
        </property>
        <property default="module.driver.spi.bit_order.bit_order_msb_first" display="Bit Order" id="module.driver.spi.bit_order" description="Select the data bit order.">
            <option display="MSB First" id="module.driver.spi.bit_order.bit_order_msb_first" value="SPI_BIT_ORDER_MSB_FIRST"/>
            <option display="LSB First" id="module.driver.spi.bit_order.bit_order_lsb_first" value="SPI_BIT_ORDER_LSB_FIRST"/>
        </property>
        <property default="spi_callback" display="Callback" id="module.driver.spi.p_callback" description="A user callback function can be provided. If this callback function is provided, it will be called from the interrupt service routine (ISR).">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.driver.spi.p_callback}")</constraint>
        </property>

        <!-- SPI Extended configuration -->
        <property default="module.driver.spi.spi_clksyn.spi_clksyn" display="SPI Mode" id="module.driver.spi.spi_clksyn" description="Select the clock sync mode.">
            <option display="SPI Operation" id="module.driver.spi.spi_clksyn.spi_operation" value="SPI_SSL_MODE_SPI"/>
            <option display="Clock Synchronous Operation" id="module.driver.spi.spi_clksyn.spi_clksyn" value="SPI_SSL_MODE_CLK_SYN"/>
        </property>
        <property default="module.driver.spi.spi_comm.full_duplex" display="Full or Transmit Only Mode" id="module.driver.spi.spi_comm" description="Select Full Duplex or Transmit Only Mode.">

            <option display="Full Duplex" id="module.driver.spi.spi_comm.full_duplex" value="SPI_COMMUNICATION_FULL_DUPLEX"/>
            <option display="Transmit Only" id="module.driver.spi.spi_comm.transmit_only" value="SPI_COMMUNICATION_TRANSMIT_ONLY"/>
        </property>
        <property default="module.driver.spi.ssl_polarity.low" display="Slave Select Polarity" id="module.driver.spi.ssl_polarity" description="Select the slave select active level.">
            <option display="Active Low" id="module.driver.spi.ssl_polarity.low" value="SPI_SSLP_LOW"/>
            <option display="Active High" id="module.driver.spi.ssl_polarity.high" value="SPI_SSLP_HIGH"/>
        </property>
        <property default="module.driver.spi.ssl_select.zero" display="Select SSL(Slave Select)" id="module.driver.spi.ssl_select" description="Select which slave to use.">
            <select enum="enum.driver.spi.ssl_select"/>
        </property>
        <property default="module.driver.spi.mosi_idle_value_fixing.disable" display="MOSI Idle State" id="module.driver.spi.mosi_idle_value_fixing" description="Select the MOSI idle level if MOSI idle is enabled.">
            <option display="MOSI Idle Value Fixing Disable" id="module.driver.spi.mosi_idle_value_fixing.disable" value="SPI_MOSI_IDLE_VALUE_FIXING_DISABLE"/>
            <option display="MOSI Idle Value Fixing Low" id="module.driver.spi.mosi_idle_value_fixing.low" value="SPI_MOSI_IDLE_VALUE_FIXING_LOW"/>
            <option display="MOSI Idle Value Fixing High" id="module.driver.spi.mosi_idle_value_fixing.high" value="SPI_MOSI_IDLE_VALUE_FIXING_HIGH"/>
        </property>
        <property default="module.driver.spi.parity_mode.disable" display="Parity Mode" id="module.driver.spi.parity" description="Select the parity mode if parity is enabled.">
            <option display="Disabled" id="module.driver.spi.parity_mode.disable" value="SPI_PARITY_MODE_DISABLE"/>
            <option display="Odd" id="module.driver.spi.parity_mode.odd" value="SPI_PARITY_MODE_ODD"/>
            <option display="Even" id="module.driver.spi.parity_mode.even" value="SPI_PARITY_MODE_EVEN"/>
        </property>
        <property default="module.driver.spi.byte_swap.disable" display="Byte Swapping" id="module.driver.spi.byte_swap" description="Select the byte swap mode for 16/32-Bit Data Frames.">
            <option display="Disable" id="module.driver.spi.byte_swap.disable" value="SPI_BYTE_SWAP_DISABLE"/>
            <option display="Enable" id="module.driver.spi.byte_swap.enable" value="SPI_BYTE_SWAP_ENABLE"/>
        </property>
        <property default="16000000" display="Bitrate" id="module.driver.spi.bitrate" description="Enter the desired bitrate, change the bitrate to a value supported by MCU. If the requested bitrate cannot be achieved, the settings with the largest possible value that is less than or equal to the requested bitrate is used. The theoretical bitrate is printed in a comment in the generated spi_extended_cfg_t structure.">
            <constraint display="Value must be an integer greater than 0">testInteger("${module.driver.spi.bitrate}")  &amp;&amp; ("${module.driver.spi.bitrate}" &gt; 0)</constraint>
            <export><![CDATA[eval('' +
'/* INPUTS */' +
'    var bitrate = ${module.driver.spi.bitrate};' +
'    var peripheral_clock = ${board.clock.peripheral.sci};' +
'    var spbr_divisor = 4096;' +
'' +
'    /* desired_divider = SPI_CLK / bitrate. */' +
'    var desired_divider = peripheral_clock / bitrate;' +
'    var spck_div = {brdv : 0, spbr : 0};' +
'' +
'    if (desired_divider > 4096)' +
'    {' +
'        /* Configure minimum bitrate (SPI_CLK / 2) */' +
'        spck_div.brdv = 3;' +
'        spck_div.spbr = 255;' +
'        spbr_divisor = (2 * (1 << spck_div.brdv));' +
'    }' +
'    else if (desired_divider < 2)' +
'    {' +
'        /* Configure max bitrate (SPI_CLK / 2) */' +
'        spck_div.brdv = 0;' +
'        spck_div.spbr = 0;' +
'        spbr_divisor = (2 * (1 << spck_div.brdv));' +
'    }' +
'    else' +
'    {' +
'        /*' +
'         * Possible SPI_CLK dividers for values of N:' +
'         *   N = 0; div = [2,4,6,..,512]' +
'         *   N = 1; div = [4,8,12,..,1024]' +
'         *   N = 2; div = [8,16,32,..,2048]' +
'         *   N = 3; div = [16,32,64,..,4096]' +
'         */' +
'        var i = 0;' +
'        for (i = 0; i < 4; i++)' +
'        {' +
'            /* Select smallest value for N possible. */' +
'' +
'            /* div <= 512; N = 0' +
'             * 512 < div <= 1024; N=1' +
'             * ...' +
'             */' +
'            if (desired_divider <= (512 << i))' +
'            {' +
'                break;' +
'            }' +
'        }' +
'' +
'        spck_div.brdv = i;' +
'' +
'        /*' +
'         * desired_divider = 2 * (spbr + 1) * 2^i.' +
'         *' +
'         * With desired_divider and i known, solve for spbr.' +
'         *' +
'         * spbr = SPI_CLK_DIV / (2 * 2^i) - 1' +
'         */' +
'        spbr_divisor = (2 * (1 << spck_div.brdv));' +
'' +
'        /* spbr = (Smallest integer greater than or equal to SPI_CLK_DIV / (2 * 2^i)) - 1. */' +
'        spck_div.spbr = Math.ceil((desired_divider / spbr_divisor) - 1);' +
'    }' +
'' +
'    var actual_bitrate = peripheral_clock / (spbr_divisor * (spck_div.spbr + 1));' +
'    var bitrate_setting = "/* Actual calculated bitrate: " + actual_bitrate.toFixed(0) + ". */" + ' +
'               " .spbr = " + spck_div.spbr.toString() +' +
'               ", .brdv = " + spck_div.brdv.toString();' +
'    bitrate_setting' +
'')
]]>            </export>
        </property>
        <property default="module.driver.spi.spck_delay.one" display="Clock Delay" id="module.driver.spi.spck_delay" description="Configure the number of SPI clock cycles before each data frame.">
            <option display="1 Clock" id="module.driver.spi.spck_delay.one" value="SPI_DELAY_COUNT_1"/>
            <option display="2 Clocks" id="module.driver.spi.spck_delay.two" value="SPI_DELAY_COUNT_2"/>
            <option display="3 Clocks" id="module.driver.spi.spck_delay.three" value="SPI_DELAY_COUNT_3"/>
            <option display="4 Clocks" id="module.driver.spi.spck_delay.four" value="SPI_DELAY_COUNT_4"/>
            <option display="5 Clocks" id="module.driver.spi.spck_delay.five" value="SPI_DELAY_COUNT_5"/>
            <option display="6 Clocks" id="module.driver.spi.spck_delay.six" value="SPI_DELAY_COUNT_6"/>
            <option display="7 Clocks" id="module.driver.spi.spck_delay.seven" value="SPI_DELAY_COUNT_7"/>
            <option display="8 Clocks" id="module.driver.spi.spck_delay.eight" value="SPI_DELAY_COUNT_8"/>
        </property>
        <property default="module.driver.spi.ssl_negation_delay.one" display="SSL Negation Delay" id="module.driver.spi.ssl_negation_delay" description="Configure the number of SPI clock cycles after each data frame.">
            <option display="1 Clock" id="module.driver.spi.ssl_negation_delay.one" value="SPI_DELAY_COUNT_1"/>
            <option display="2 Clocks" id="module.driver.spi.ssl_negation_delay.two" value="SPI_DELAY_COUNT_2"/>
            <option display="3 Clocks" id="module.driver.spi.ssl_negation_delay.three" value="SPI_DELAY_COUNT_3"/>
            <option display="4 Clocks" id="module.driver.spi.ssl_negation_delay.four" value="SPI_DELAY_COUNT_4"/>
            <option display="5 Clocks" id="module.driver.spi.ssl_negation_delay.five" value="SPI_DELAY_COUNT_5"/>
            <option display="6 Clocks" id="module.driver.spi.ssl_negation_delay.six" value="SPI_DELAY_COUNT_6"/>
            <option display="7 Clocks" id="module.driver.spi.ssl_negation_delay.seven" value="SPI_DELAY_COUNT_7"/>
            <option display="8 Clocks" id="module.driver.spi.ssl_negation_delay.eight" value="SPI_DELAY_COUNT_8"/>
        </property>
        <property default="module.driver.spi.next_access_delay.one" display="Next Access Delay" id="module.driver.spi.next_access_delay" description="Configure the number of SPI clock cycles between each data frame.">
            <option display="1 Clock" id="module.driver.spi.next_access_delay.one" value="SPI_DELAY_COUNT_1"/>
            <option display="2 Clocks" id="module.driver.spi.next_access_delay.two" value="SPI_DELAY_COUNT_2"/>
            <option display="3 Clocks" id="module.driver.spi.next_access_delay.three" value="SPI_DELAY_COUNT_3"/>
            <option display="4 Clocks" id="module.driver.spi.next_access_delay.four" value="SPI_DELAY_COUNT_4"/>
            <option display="5 Clocks" id="module.driver.spi.next_access_delay.five" value="SPI_DELAY_COUNT_5"/>
            <option display="6 Clocks" id="module.driver.spi.next_access_delay.six" value="SPI_DELAY_COUNT_6"/>
            <option display="7 Clocks" id="module.driver.spi.next_access_delay.seven" value="SPI_DELAY_COUNT_7"/>
            <option display="8 Clocks" id="module.driver.spi.next_access_delay.eight" value="SPI_DELAY_COUNT_8"/>
        </property>
        <peripheral name="SPI${module.driver.spi.channel}" component="spi${module.driver.spi.channel}" />
        <symbol id="symbol.driver.spi.name" value="${module.driver.spi.name}"/>
        <symbol id="symbol.driver.spi.guard.open" value="${module.driver.spi.name}_open_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.open" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_Open"/>
        <symbol id="symbol.driver.spi.guard.read" value="${module.driver.spi.name}_read_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.read" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_Read"/>
        <symbol id="symbol.driver.spi.guard.write" value="${module.driver.spi.name}_write_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.write" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_Write"/>
        <symbol id="symbol.driver.spi.guard.write_read" value="${module.driver.spi.name}_write_read_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.write_read" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_WriteRead"/>
        <symbol id="symbol.driver.spi.guard.close" value="${module.driver.spi.name}_close_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.close" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_Close"/>
        <symbol id="symbol.driver.spi.guard.calculate_bitrate" value="${module.driver.spi.name}_calculate_bitrate_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.calculate_bitrate" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_CalculateBitrate"/>
        <symbol id="symbol.driver.spi.guard.callback_set" value="${module.driver.spi.name}_callback_set_guard"/>
        <symbol id="symbol.driver.spi.guard.macro.callback_set" value="FSP_GUARD_${module.driver.spi.name}_R_SPI_CallbackSet"/>
        <symbol id="symbol.driver.spi.nsc_api" value="${module.driver.spi.name}_nsc_api"/>
        <symbol id="symbol.driver.spi.P_TRANSFER_RX" value="${module.driver.spi.name}_P_TRANSFER_RX"/>
        <symbol id="symbol.driver.spi.P_TRANSFER_TX" value="${module.driver.spi.name}_P_TRANSFER_TX"/>
        <symbol id="symbol.driver.spi.cfg" value="${module.driver.spi.name}_cfg"/>
        <symbol id="symbol.driver.spi.ctrl" value="${module.driver.spi.name}_ctrl"/>
        <symbol id="symbol.driver.spi.ext_cfg" value="${module.driver.spi.name}_ext_cfg"/>
        <header>
/** SPI on SPI Instance. */
extern const spi_instance_t ${module.driver.spi.name};

/** Access the SPI instance using these structures when calling API functions directly (::p_api is not used). */
extern spi_instance_ctrl_t ${module.driver.spi.name}_ctrl;
extern const spi_cfg_t ${module.driver.spi.name}_cfg;

/** Callback used by SPI Instance. */
#ifndef ${module.driver.spi.p_callback}
void ${module.driver.spi.p_callback}(spi_callback_args_t * p_args);
#endif


#define RA_NOT_DEFINED (1)
#if (RA_NOT_DEFINED == ${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name})
    #define ${module.driver.spi.name}_P_TRANSFER_TX (NULL)
#else
    #define ${module.driver.spi.name}_P_TRANSFER_TX (&amp;${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.name})
#endif
#if (RA_NOT_DEFINED == ${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name})
    #define ${module.driver.spi.name}_P_TRANSFER_RX (NULL)
#else
    #define ${module.driver.spi.name}_P_TRANSFER_RX (&amp;${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.name})
#endif
#undef RA_NOT_DEFINED

        </header>
        <includes>
#include &quot;r_spi.h&quot;
        </includes>
        <declarations>
#define RA_NOT_DEFINED (UINT32_MAX)
#if (RA_NOT_DEFINED) != (${module.driver.spi_on_spi.requires.transfer_tx::module.driver.transfer.offset})

/* If the transfer module is DMAC, define a DMAC transfer callback. */
#include "r_dmac.h"
extern void spi_tx_dmac_callback(spi_instance_ctrl_t const * const p_ctrl);

void ${module.driver.spi.name}_tx_transfer_callback (dmac_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    spi_tx_dmac_callback(&amp;${module.driver.spi.name}_ctrl);
}
#endif

#if (RA_NOT_DEFINED) != (${module.driver.spi_on_spi.requires.transfer_rx::module.driver.transfer.offset})

/* If the transfer module is DMAC, define a DMAC transfer callback. */
#include "r_dmac.h"
extern void spi_rx_dmac_callback(spi_instance_ctrl_t const * const p_ctrl);

void ${module.driver.spi.name}_rx_transfer_callback (dmac_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    spi_rx_dmac_callback(&amp;${module.driver.spi.name}_ctrl);
}
#endif
#undef RA_NOT_DEFINED

spi_instance_ctrl_t ${module.driver.spi.name}_ctrl;

/** SPI extended configuration for SPI HAL driver */
const spi_extended_cfg_t ${module.driver.spi.name}_ext_cfg =
{
    .spi_clksyn         = ${module.driver.spi.spi_clksyn},
    .spi_comm           = ${module.driver.spi.spi_comm},
    .ssl_polarity        = ${module.driver.spi.ssl_polarity},
    .ssl_select          = ${module.driver.spi.ssl_select},
    .mosi_idle           = ${module.driver.spi.mosi_idle_value_fixing},
    .parity              = ${module.driver.spi.parity},
    .byte_swap           = ${module.driver.spi.byte_swap},
    .spck_div            = {
        ${module.driver.spi.bitrate}
    },
    .spck_delay          = ${module.driver.spi.spck_delay},
    .ssl_negation_delay  = ${module.driver.spi.ssl_negation_delay},
    .next_access_delay   = ${module.driver.spi.next_access_delay}
 };

/** SPI configuration for SPI HAL driver */
const spi_cfg_t ${module.driver.spi.name}_cfg =
{
    .channel             = ${module.driver.spi.channel},

#if defined(VECTOR_NUMBER_SPI${module.driver.spi.channel}_RXI)
    .rxi_irq             = VECTOR_NUMBER_SPI${module.driver.spi.channel}_RXI,
#else
    .rxi_irq             = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SPI${module.driver.spi.channel}_TXI)
    .txi_irq             = VECTOR_NUMBER_SPI${module.driver.spi.channel}_TXI,
#else
    .txi_irq             = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SPI${module.driver.spi.channel}_TEI)
    .tei_irq             = VECTOR_NUMBER_SPI${module.driver.spi.channel}_TEI,
#else
    .tei_irq             = FSP_INVALID_VECTOR,
#endif
#if defined(VECTOR_NUMBER_SPI${module.driver.spi.channel}_ERI)
    .eri_irq             = VECTOR_NUMBER_SPI${module.driver.spi.channel}_ERI,
#else
    .eri_irq             = FSP_INVALID_VECTOR,
#endif

    .rxi_ipl             = ${module.driver.spi.rxi_ipl},
    .txi_ipl             = ${module.driver.spi.txi_ipl},
    .tei_ipl             = ${module.driver.spi.tei_ipl},
    .eri_ipl             = ${module.driver.spi.eri_ipl},

    .operating_mode      = ${module.driver.spi.operating_mode},

    .clk_phase           = ${module.driver.spi.clk_phase},
    .clk_polarity        = ${module.driver.spi.clk_polarity},

    .mode_fault          = ${module.driver.spi.mode_fault},
    .bit_order           = ${module.driver.spi.bit_order},
    .p_transfer_tx       = ${module.driver.spi.name}_P_TRANSFER_TX,
    .p_transfer_rx       = ${module.driver.spi.name}_P_TRANSFER_RX,
    .p_callback          = ${module.driver.spi.p_callback},

    .p_context           = NULL,
    .p_extend            = (void *)&amp;${module.driver.spi.name}_ext_cfg,
};

/* Instance structure to use this module. */
const spi_instance_t ${module.driver.spi.name} =
{
    .p_ctrl        = &amp;${module.driver.spi.name}_ctrl,
    .p_cfg         = &amp;${module.driver.spi.name}_cfg,
    .p_api         = &amp;g_spi_on_spi
};
        </declarations>
        <guard>
            <header>

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_open_guard(spi_ctrl_t *p_api_ctrl, spi_cfg_t const *const p_cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_read_guard(spi_ctrl_t *const p_api_ctrl, void *p_dest, uint32_t const length, spi_bit_width_t const bit_width);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_guard(spi_ctrl_t *const p_api_ctrl, void const *p_src, uint32_t const length, spi_bit_width_t const bit_width);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_read_guard_fanin(spi_ctrl_t *const p_api_ctrl, spi_write_read_guard_args_t *args);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_close_guard(spi_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_calculate_bitrate_guard(uint32_t bitrate, rspck_div_setting_t *spck_div);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_callback_set_guard(spi_ctrl_t *const p_api_ctrl, void(*p_callback)(spi_callback_args_t *), void const *const p_context, spi_callback_args_t *const p_callback_memory);

            </header>
            <template name="${module.driver.spi.name}_guard.c">
                <![CDATA[
                    #include "guard.h"


BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_open_guard (spi_ctrl_t *p_api_ctrl, spi_cfg_t const *const p_cfg)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(p_cfg);

    return R_SPI_Open(&${module.driver.spi.name}_ctrl, &${module.driver.spi.name}_cfg);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_read_guard (spi_ctrl_t *const p_api_ctrl, void *p_dest, uint32_t const length, spi_bit_width_t const bit_width)
{
    uint32_t byte_width = 1;
    if (bit_width > SPI_BIT_WIDTH_16_BITS)
    {
        byte_width = 4;
    }
    else if (bit_width > SPI_BIT_WIDTH_8_BITS)
    {
        byte_width = 2;
    }

    uint32_t byte_length = byte_width * length;

    /* Verify all pointers are in non-secure memory. */
    void * p_dest_checked = cmse_check_address_range((void *) p_dest, byte_length, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_dest_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SPI_Read(&${module.driver.spi.name}_ctrl, p_dest_checked, length, bit_width);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_guard (spi_ctrl_t *const p_api_ctrl, void const *p_src, uint32_t const length, spi_bit_width_t const bit_width)
{
    uint32_t byte_width = 1;
    if (bit_width > SPI_BIT_WIDTH_16_BITS)
    {
        byte_width = 4;
    }
    else if (bit_width > SPI_BIT_WIDTH_8_BITS)
    {
        byte_width = 2;
    }

    uint32_t byte_length = byte_width * length;

    /* Verify all pointers are in non-secure memory. */
    void const * p_src_checked = cmse_check_address_range((void *) p_src, byte_length, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_src_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SPI_Write(&${module.driver.spi.name}_ctrl, p_src_checked, length, bit_width);
}

/* This function has been modified to reduce the number of arguments. */
BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_read_guard_fanin (spi_ctrl_t *const p_api_ctrl, spi_write_read_guard_args_t *args)
{
    /* Verify all pointers are in non-secure memory. */
    spi_write_read_guard_args_t *args_checked = cmse_check_pointed_object (args, CMSE_AU_NONSECURE);
    FSP_ASSERT (args_checked != NULL);

    uint32_t byte_width = 1;
    if (args_checked->bit_width > SPI_BIT_WIDTH_16_BITS)
    {
        byte_width = 4;
    }
    else if (args_checked->bit_width > SPI_BIT_WIDTH_8_BITS)
    {
        byte_width = 2;
    }

    uint32_t byte_length = byte_width * args_checked->length;

    void const *p_src_checked = cmse_check_address_range ((void*) args_checked->p_src, byte_length, CMSE_AU_NONSECURE);
    FSP_ASSERT (p_src_checked != NULL);
    void *p_dest_checked = cmse_check_address_range (args_checked->p_dest, byte_length, CMSE_AU_NONSECURE);
    FSP_ASSERT (p_dest_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SPI_WriteRead(&${module.driver.spi.name}_ctrl, p_src_checked, p_dest_checked, args_checked->length, args_checked->bit_width);
}


BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_close_guard (spi_ctrl_t *const p_api_ctrl)
{
    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);

    return R_SPI_Close(&${module.driver.spi.name}_ctrl);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_calculate_bitrate_guard (uint32_t bitrate, rspck_div_setting_t *spck_div)
{
    /* Verify all pointers are in non-secure memory. */
    rspck_div_setting_t * spck_div_checked = cmse_check_pointed_object(spck_div, CMSE_AU_NONSECURE);
    FSP_ASSERT(spck_div_checked != NULL);

    /* TODO: add your own security checks here */

    return R_SPI_CalculateBitrate(bitrate, spck_div_checked);
}

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_callback_set_guard (spi_ctrl_t *const p_api_ctrl, void(*p_callback)(spi_callback_args_t *), void const *const p_context, spi_callback_args_t *const p_callback_memory)
{
    /* Verify all pointers are in non-secure memory. */
    void(*p_callback_checked)(spi_callback_args_t *) = (void(*)(spi_callback_args_t *)) cmse_check_address_range((void *) p_callback, sizeof(void *), CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_checked != NULL);
    spi_callback_args_t *const p_callback_memory_checked = cmse_check_pointed_object(p_callback_memory, CMSE_AU_NONSECURE);
    FSP_ASSERT(p_callback_memory_checked != NULL);

    /* TODO: add your own security checks here */

    FSP_PARAMETER_NOT_USED(p_api_ctrl);
    FSP_PARAMETER_NOT_USED(p_context);

    return R_SPI_CallbackSet(&${module.driver.spi.name}_ctrl, p_callback_checked, p_context, p_callback_memory_checked);
}

                ]]>
            </template>
        </guard>
        <nsc>
            <header>

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_Open() ${module.driver.spi.name}_open_guard(FSP_SECURE_ARGUMENT, FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_Read(p_dest, length, bit_width) ${module.driver.spi.name}_read_guard(FSP_SECURE_ARGUMENT, p_dest, length, bit_width)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_Write(p_src, length, bit_width) ${module.driver.spi.name}_write_guard(FSP_SECURE_ARGUMENT, p_src, length, bit_width)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_WriteRead(p_src, p_dest, length, bit_width) ${module.driver.spi.name}_write_read_guard(FSP_SECURE_ARGUMENT, p_src, p_dest, length, bit_width)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_Close() ${module.driver.spi.name}_close_guard(FSP_SECURE_ARGUMENT)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_CalculateBitrate(bitrate, spck_div) ${module.driver.spi.name}_calculate_bitrate_guard(bitrate, spck_div)

#define FSP_GUARD_${module.driver.spi.name}_R_SPI_CallbackSet(p_callback, p_context, p_callback_memory) ${module.driver.spi.name}_callback_set_guard(FSP_SECURE_ARGUMENT, p_callback, p_context, p_callback_memory)



BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_open_guard(spi_ctrl_t *p_api_ctrl, spi_cfg_t const *const p_cfg);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_read_guard(spi_ctrl_t *const p_api_ctrl, void *p_dest, uint32_t const length, spi_bit_width_t const bit_width);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_guard(spi_ctrl_t *const p_api_ctrl, void const *p_src, uint32_t const length, spi_bit_width_t const bit_width);

inline fsp_err_t ${module.driver.spi.name}_write_read_guard(spi_ctrl_t *const p_api_ctrl, void const *p_src, void *p_dest, uint32_t const length, spi_bit_width_t const bit_width);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_write_read_guard_fanin(spi_ctrl_t * const p_api_ctrl, spi_write_read_guard_args_t * const p_args);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_close_guard(spi_ctrl_t *const p_api_ctrl);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_calculate_bitrate_guard(uint32_t bitrate, rspck_div_setting_t *spck_div);

BSP_CMSE_NONSECURE_ENTRY fsp_err_t ${module.driver.spi.name}_callback_set_guard(spi_ctrl_t *const p_api_ctrl, void(*p_callback)(spi_callback_args_t *), void const *const p_context, spi_callback_args_t *const p_callback_memory);


extern const spi_instance_t ${module.driver.spi.name};

fsp_err_t ${module.driver.spi.name}_write_read_guard (spi_ctrl_t * const p_api_ctrl, void const * p_src, void * p_dest, uint32_t const length, spi_bit_width_t const bit_width);
            </header>
            <declarations>
                <![CDATA[
fsp_err_t ${module.driver.spi.name}_write_read_guard (spi_ctrl_t * const p_api_ctrl, void const * p_src, void * p_dest, uint32_t const length, spi_bit_width_t const bit_width)
{
    /* Pack arguments into a struct */
    spi_write_read_guard_args_t args =
    {
        .p_src     = p_src,
        .p_dest    = p_dest,
        .length    = length,
        .bit_width = bit_width
    };

    /* Pass the struct to the NSC fan-in guard function */
    return ${module.driver.spi.name}_write_read_guard_fanin(p_api_ctrl, &args);
}

static const spi_api_t ${module.driver.spi.name}_nsc_api =
{
    .open = ${module.driver.spi.name}_open_guard,
    .read = ${module.driver.spi.name}_read_guard,
    .write = ${module.driver.spi.name}_write_guard,
    .writeRead = ${module.driver.spi.name}_write_read_guard,
    .close = ${module.driver.spi.name}_close_guard,
    .callbackSet = ${module.driver.spi.name}_callback_set_guard,
};
const spi_instance_t ${module.driver.spi.name} =
{
    .p_api = &${module.driver.spi.name}_nsc_api,
    .p_ctrl = FSP_SECURE_ARGUMENT,
    .p_cfg = FSP_SECURE_ARGUMENT,
};
                ]]>
            </declarations>
        </nsc>
        <api configurable="true">
            <file>ra/fsp/inc/api/r_spi_api.h</file>
            <file>ra/fsp/inc/api/r_transfer_api.h</file>
            <file>ra/fsp/inc/instances/r_spi.h</file>
        </api>
    </module>
</raModuleDescription>
