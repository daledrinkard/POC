<?xml version="1.0" ?>
<raModuleDescription>
    <config id="config.middleware.mcuboot" path="mcu-tools/include/mcuboot_config/mcuboot_config.h" version="0">
        <property default="" description="Add a path to your custom mcuboot_config.h file. It can be used to override some or all of the configurations defined here, and to define additional configurations." display="General|Custom mcuboot_config.h" id="config.middleware.mcuboot.custom_mcuboot_config">
            <export>eval('' +
'var input = "${config.middleware.mcuboot.custom_mcuboot_config}";' +
'if (input != "")' +
'{' +
'    input = \'#include "\' + input + \'"\';' +
'}' +
'    input' +
                '')</export>
        </property>
        <property default="config.middleware.mcuboot.signature.ecdsap256" display="Signing and Encryption Options|Signature Type" id="config.middleware.mcuboot.signature" description="Configure the signature type.">
            <option display="None" id="config.middleware.mcuboot.signature.none" value=""/>
            <option display="ECDSA P-256" id="config.middleware.mcuboot.signature.ecdsap256" value="#define MCUBOOT_SIGN_EC256"/>
            <option display="ECDSA P-384" id="config.middleware.mcuboot.signature.ecdsap384" value="#define MCUBOOT_SIGN_EC384"/>
            <option display="RSA 2048" id="config.middleware.mcuboot.signature.rsa2048" value="#define MCUBOOT_SIGN_RSA_LEN (2048)"/>
            <option display="RSA 3072" id="config.middleware.mcuboot.signature.rsa3072" value="#define MCUBOOT_SIGN_RSA_LEN (3072)"/>
        </property>
        <property default="config.middleware.mcuboot.upgrade_mode.overwrite_only" display="General|Upgrade Mode" id="config.middleware.mcuboot.upgrade_mode" description="Swap supports A/B image swapping with rollback. Other modes with simpler code path, which only supports overwriting the existing image with the update image (Overwrite Only) or running the newest image directly from its flash partition (Direct XIP), are also available.">
            <option display="Swap" id="config.middleware.mcuboot.upgrade_mode.swap" value=""/>
            <option display="Overwrite Only" id="config.middleware.mcuboot.upgrade_mode.overwrite_only" value="#define MCUBOOT_OVERWRITE_ONLY"/>
            <option display="Overwrite Only Fast" id="config.middleware.mcuboot.upgrade_mode.overwrite_only_fast" value="#define MCUBOOT_OVERWRITE_ONLY_FAST"/>
            <option display="Direct XIP" id="config.middleware.mcuboot.upgrade_mode.direct_xip" value="#define MCUBOOT_DIRECT_XIP"/>
            <!-- <option display="Direct XIP with Revert" id="config.middleware.mcuboot.upgrade_mode.direct_xip_with_revert" value="#define MCUBOOT_DIRECT_XIP_REVERT"/> -->
        </property>
        <property default="config.middleware.mcuboot.validate_primary.enabled" display="General|Validate Primary Image" id="config.middleware.mcuboot.validate_primary" description="Always check the signature of the image in the primary slot before booting, even if no upgrade was performed. This is recommended if the boot time penalty is acceptable.">
            <option display="Enabled" id="config.middleware.mcuboot.validate_primary.enabled" value="#define MCUBOOT_VALIDATE_PRIMARY_SLOT"/>
            <option display="Disabled" id="config.middleware.mcuboot.validate_primary.disabled" value=""/>
        </property>
        <property default="config.middleware.mcuboot.downgrade_prevention.disabled" display="General|Downgrade Prevention (Overwrite Only)" id="config.middleware.mcuboot.downgrade_prevention" description="Prevent downgrades by enforcing incrementing version numbers. When this option is set, any upgrade must have greater major version or greater minor version with equal major version. This mechanism only protects against some attacks against version downgrades (for example, a JTAG could be used to write an older version).">
            <option display="Enabled" id="config.middleware.mcuboot.downgrade_prevention.enabled" value="#define MCUBOOT_DOWNGRADE_PREVENTION"/>
            <option display="Disabled" id="config.middleware.mcuboot.downgrade_prevention.disabled" value=""/>
        </property>
        <property default="config.middleware.mcuboot.image_number.1" display="General|Number of Images Per Application" id="config.middleware.mcuboot.image_number" description="Number of separately updateable images.">
            <option display="1" id="config.middleware.mcuboot.image_number.1" value="1"/>
            <option display="2 (TrustZone)" id="config.middleware.mcuboot.image_number.2" value="2"/>
        </property>
        <property default="" display="General|Watchdog Feed" id="config.middleware.mcuboot.watchdog_feed" description="This function might be implemented if the OS / HW watchdog is enabled while doing a swap upgrade and the time it takes for a swapping is long enough to cause an unwanted reset. If implementing this, the OS main.c must also enable the watchdog (if required)!">
        </property>
        <property default="0x20000" description="Size of the flash reserved for the bootloader." display="Flash Layout|Bootloader Flash Area Size (Bytes)" id="config.middleware.mcuboot.flash_area_bootloader_size">
            <constraint display="Value must be an integer multiple of the largest erase size on the mcu.">testInteger("${config.middleware.mcuboot.flash_area_bootloader_size}")  &amp;&amp; (${config.middleware.mcuboot.flash_area_bootloader_size} &gt; 0)</constraint>
        </property>
        <property default="0x200" description="Size of the flash reserved for the application image header. Must meet minimum VTOR alignment requirements for the core (0x200 for all RA MCUs)." display="Flash Layout|Image 1 Header Size (Bytes)" id="config.middleware.mcuboot.flash_area_bootloader_header_size">
        </property>
        <property default="0x20000" description="Size of the application image 1, including the header and trailer. For TrustZone projects, enter the combined size of the Secure and Non-Secure Callable regions if the Non-Secure image can be updated separately, or enter the size of the entire image slot if Secure, Non-Secure Callable, and Non-Secure regions are updated as a single image." display="Flash Layout|Image 1 Flash Area Size (Bytes)" id="config.middleware.mcuboot.flash_s_partition_size">
            <constraint display="Value must be an integer multiple of the largest erase size on the mcu.">testInteger("${config.middleware.mcuboot.flash_s_partition_size}")  &amp;&amp; (${config.middleware.mcuboot.flash_s_partition_size} &gt; 0)</constraint>
        </property>
        <property default="0x0" description="Size of the scratch area. Only required for swap update method." display="Flash Layout|Scratch Flash Area Size (Bytes)" id="config.middleware.mcuboot.scratch_partition_size">
            <constraint display="Value must be an integer multiple of the largest erase size on the mcu.">testInteger("${config.middleware.mcuboot.scratch_partition_size}")</constraint>
        </property>
        <property default="config.middleware.mcuboot.measured_boot.disabled" display="General|Measured Boot" id="config.middleware.mcuboot.measured_boot" description="Copies the boot data into the secure RAM, intended to be used by the secure App.">
            <option display="Enabled" id="config.middleware.mcuboot.measured_boot.enabled" value="#define MCUBOOT_MEASURED_BOOT"/>
            <option display="Disabled" id="config.middleware.mcuboot.measured_boot.disabled" value=""/>
        </property>
        <property default="config.middleware.mcuboot.data_sharing.disabled" display="General|Data Sharing" id="config.middleware.mcuboot.data_sharing" description="Copies the user data into the secure RAM, intended to be used by the secure App.">
            <option display="Enabled" id="config.middleware.mcuboot.data_sharing.enabled" value="#define MCUBOOT_DATA_SHARING"/>
            <option display="Disabled" id="config.middleware.mcuboot.data_sharing.disabled" value=""/>
        </property>
        <property default="" display="Flash Configuration|Dual Bank Mode" id="config.middleware.mcuboot.flash_lp.dual_bank" description="Enable dual bank mode for Direct XIP.">
            <select enum="enum.mcu.flash_lp.dual_bank"/>
        </property>
        <property default="0x64" description="Maximum size of the boot record." display="Data Sharing|Maximum Measured Boot Record Size (Bytes)" id="config.middleware.mcuboot.max_measured_boot_record">
            <constraint display="Value must be an integer.">testInteger("${config.middleware.mcuboot.max_measured_boot_record}")</constraint>
        </property>
        <property default="0x380" description="Size of the shared RAM area. Required for Measured Boot." display="Data Sharing|Shared Data Size (Bytes)" id="config.middleware.mcuboot.shared_data_size">
            <constraint display="Value must be an integer.">testInteger("${config.middleware.mcuboot.shared_data_size}")</constraint>
        </property>
        <property default="0x20000000" description="Shared RAM start address. Required for Measured Boot." display="Data Sharing|Shared Data Address" id="config.middleware.mcuboot.shared_data_base">
            <constraint display="Value must be an integer">testInteger("${config.middleware.mcuboot.shared_data_base}")</constraint>
        </property>
        <property default="0x0" description="Size of the Non-Secure Callable region of the Secure image." display="Flash Layout|TrustZone|Non-Secure Callable Region Size (Bytes)" id="config.middleware.mcuboot.flash_nsc_partition_size">
            <constraint display="Value must be an integer multiple of the 1024.">testInteger("${config.middleware.mcuboot.flash_nsc_partition_size}") &amp;&amp; ((${config.middleware.mcuboot.flash_nsc_partition_size}) % 1024 == 0)</constraint>
        </property>
        <property default="0x0" description="Size of the Non-Secure region. This must be non-zero for all TrustZone projects to ensure memory is partitioned correctly, even if the Secure and Non-Secure regions are treated as a single image. If the Non-Secure region can be updated separately, this size must account for the header and trailer." display="Flash Layout|TrustZone|Non-Secure Flash Area Size (Bytes) (TrustZone Non-Secure)" id="config.middleware.mcuboot.flash_ns_partition_size">
            <constraint display="Value must be an integer multiple of the largest erase size on the mcu.">testInteger("${config.middleware.mcuboot.flash_ns_partition_size}")</constraint>
        </property>
        <property default="0x0" description="Size of the Non-Secure Callable RAM region of the Secure image." display="Flash Layout|TrustZone|Non-Secure Callable RAM Region Size (Bytes)" id="config.middleware.mcuboot.ram_nsc_partition_size">
            <constraint display="Value must be an integer multiple of the 1024.">testInteger("${config.middleware.mcuboot.ram_nsc_partition_size}") &amp;&amp; ((${config.middleware.mcuboot.ram_nsc_partition_size}) % 1024 == 0)</constraint>
        </property>
        <property default="0x0" description="Size of the Non-Secure RAM region. This must be non-zero for all TrustZone projects to ensure memory is partitioned correctly, even if the Secure and Non-Secure regions are treated as a single image." display="Flash Layout|TrustZone|Non-Secure RAM Region Size (Bytes) (TrustZone Non-Secure)" id="config.middleware.mcuboot.ram_ns_partition_size">
            <constraint display="Value must be an integer multiple of the 8192.">testInteger("${config.middleware.mcuboot.ram_ns_partition_size}") &amp;&amp; ((${config.middleware.mcuboot.ram_ns_partition_size}) % 8192 == 0)</constraint>
        </property>
        <property default="0x200" description="Size of the flash reserved for the application image header for Image 2." display="Flash Layout|TrustZone|Image 2 Header Size (Bytes)" id="config.middleware.mcuboot.flash_area_bootloader_header_size_2">
        </property>
        <property default="" description="Create CBOR encoded boot record TLV. Represents the role of the software component (e.g. CoFM for coprocessor firmware). [max. 12 characters]" display="Signing and Encryption Options|Boot Record" id="config.middleware.mcuboot.boot_record">
            <constraint display="String length must be 12 characters or less.">"${config.middleware.mcuboot.boot_record}".length &lt;= 12</constraint>
        </property>
        <property default="" description="Create CBOR encoded boot record TLV for Image 2. Represents the role of the software component (e.g. CoFM for coprocessor firmware). [max. 12 characters]" display="Signing and Encryption Options|TrustZone|Boot Record (Image 2)" id="config.middleware.mcuboot.boot_record_image_2">
            <constraint display="String length must be 12 characters or less.">"${config.middleware.mcuboot.boot_record_image_2}".length &lt;= 12</constraint>
        </property>
        <property default=" --confirm" description="Add any custom options to pass to imgtool.py here. --pad places a trailer on the image that indicates that the image should be considered an upgrade.  Writing this image in the secondary slot will then cause the bootloader to upgrade to it. --confirm marks the image as confirmed, which causes the upgrade to be permanent." display="Signing and Encryption Options|Custom" id="config.middleware.mcuboot.sign_custom">
        </property>
        <property default=" --confirm" description="Add any custom options to pass to imgtool.py here. --pad places a trailer on the image that indicates that the image should be considered an upgrade.  Writing this image in the secondary slot will then cause the bootloader to upgrade to it. --confirm marks the image as confirmed, which causes the upgrade to be permanent." display="Signing and Encryption Options|TrustZone|Custom (Image 2)" id="config.middleware.mcuboot.sign_custom_image_2">
        </property>
        <property default="python" description="Name of the python command to use. Default is python, but can be updated to python3 for Linux or an absolute path if needed." display="Signing and Encryption Options|Python" id="config.middleware.mcuboot.python_command">
        </property>
        <property default="" id="config.middleware.mcuboot.alignment" description="">
            <select enum="enum.mcu.flash.min_write_size"/>
        </property>
        <property default="" id="config.middleware.mcuboot.sector_size" description="">
            <select enum="enum.mcu.flash.min_erase_size"/>
        </property>
        <property default="config.middleware.mcuboot.encryption_key.none" display="Signing and Encryption Options|Encryption Scheme" id="config.middleware.mcuboot.encryption_key" description=" Choose the encryption scheme.">
            <option display="ECIES-P256" id="config.middleware.mcuboot.encryption_key.ec256" value="#define MCUBOOT_ENCRYPT_EC256"/>
            <option display="RSA-OAEP (RSA 2048 only)" id="config.middleware.mcuboot.encryption_key.rsa" value="#define MCUBOOT_ENCRYPT_RSA"/>
            <option display="Encryption Disabled" id="config.middleware.mcuboot.encryption_key.none" value=""/>
        </property>
        <content>

${config.middleware.mcuboot.custom_mcuboot_config}

#ifdef __cplusplus
extern "C" {
#endif

${config.middleware.mcuboot.signature}
#ifdef MCUBOOT_SIGN_RSA_LEN
#define MCUBOOT_SIGN_RSA
#endif

${config.middleware.mcuboot.upgrade_mode}
#ifdef MCUBOOT_OVERWRITE_ONLY_FAST
#define MCUBOOT_OVERWRITE_ONLY
#endif
#ifdef MCUBOOT_DIRECT_XIP_REVERT
#define MCUBOOT_DIRECT_XIP
#endif

#if  ((1 == ${interface.driver.mcuboot_tinycrypt}) || (1 == ${interface.driver.tinycrypt}))
#define MCUBOOT_USE_TINYCRYPT
#if  (1 == ${interface.driver.tinycrypt_acceleration})
#define RM_MCUBOOT_PORT_USE_TINYCRYPT_ACCELERATION
#endif
#elif (1 == ${interface.driver.psa_crypto})
#define MCUBOOT_USE_MBED_TLS
#else
#define MCUBOOT_USE_USER_DEFINED_CRYPTO_STACK
#endif

#ifdef MCUBOOT_USE_USER_DEFINED_CRYPTO_STACK
#include "sce9_ecdsa_p256.h"
#endif

#include "bootutil/crypto/common.h"

#if (${interface.driver.rm_mcuboot_external_memory_qspi} > 0)
#define RM_MCUBOOT_PORT_CFG_SECONDARY_USE_QSPI
#endif

#if (${interface.driver.rm_mcuboot_external_memory_ospi_b} > 0)
#define RM_MCUBOOT_PORT_CFG_SECONDARY_USE_OSPI_B
#endif

#if ((${interface.driver.rm_mcuboot_external_memory_qspi} > 0) || (${interface.driver.rm_mcuboot_external_memory_ospi_b} > 0))
#define RM_MCUBOOT_PORT_CFG_SECONDARY_USE_XSPI
#endif

${config.middleware.mcuboot.validate_primary}

${config.middleware.mcuboot.downgrade_prevention}

${config.middleware.mcuboot.measured_boot}

${config.middleware.mcuboot.data_sharing}

#define MCUBOOT_DUALBANK_FLASH_LP (${config.middleware.mcuboot.dualbank.flashlp})

#define MAX_BOOT_RECORD_SZ ${config.middleware.mcuboot.max_measured_boot_record}

#define MCUBOOT_SHARED_DATA_BASE ${config.middleware.mcuboot.shared_data_base}

#define MCUBOOT_SHARED_DATA_SIZE ${config.middleware.mcuboot.shared_data_size}

#define MCUBOOT_USE_FLASH_AREA_GET_SECTORS

#define MCUBOOT_IMAGE_NUMBER (${config.middleware.mcuboot.image_number})

#if (1 == (${interface.middleware.mcuboot_logging}))
#define MCUBOOT_HAVE_LOGGING    1
#endif

${config.middleware.mcuboot.encryption_key}
#if defined (MCUBOOT_ENCRYPT_EC256) || defined (MCUBOOT_ENCRYPT_RSA)
#ifndef _RA_BOOT_IMAGE
#define MCUBOOT_ENC_IMAGES
#endif
#endif

/*
 * Assertions
 */

/* Uncomment if your platform has its own mcuboot_config/mcuboot_assert.h.
 * If so, it must provide an ASSERT macro for use by bootutil. Otherwise,
 * "assert" is used. */
// #define MCUBOOT_HAVE_ASSERT_H

/*
 * Watchdog feeding
 */

#ifndef MCUBOOT_WATCHDOG_FEED
#define MCUBOOT_WATCHDOG_FEED()  ${config.middleware.mcuboot.watchdog_feed}
#endif

// do { /* Do nothing. */ } while (0)

#include "bsp_api.h"

#define RM_MCUBOOT_PORT_CFG_MCUBOOT_SIZE           (${config.middleware.mcuboot.flash_area_bootloader_size})
#if (MCUBOOT_IMAGE_NUMBER == 1)
 #define RM_MCUBOOT_PORT_CFG_PARTITION_SIZE        (${config.middleware.mcuboot.flash_s_partition_size})
#else
 #define RM_MCUBOOT_PORT_CFG_S_PARTITION_SIZE      (${config.middleware.mcuboot.flash_s_partition_size})
#endif
#define RM_MCUBOOT_PORT_CFG_NS_PARTITION_SIZE      (${config.middleware.mcuboot.flash_ns_partition_size})
#define RM_MCUBOOT_PORT_CFG_SCRATCH_SIZE           (${config.middleware.mcuboot.scratch_partition_size})

#if BSP_FEATURE_FLASH_HP_VERSION &gt; 0
 #define FLASH_AREA_IMAGE_SECTOR_SIZE    (BSP_FEATURE_FLASH_HP_CF_REGION1_BLOCK_SIZE) /* 32 KB */
 #define MCUBOOT_BOOT_MAX_ALIGN          (BSP_FEATURE_FLASH_HP_CF_WRITE_SIZE)
#else
 #define FLASH_AREA_IMAGE_SECTOR_SIZE    (BSP_FEATURE_FLASH_LP_CF_BLOCK_SIZE)         /* 2 KB */
#endif

#if (MCUBOOT_IMAGE_NUMBER == 1)
 #define RM_MCUBOOT_LARGEST_SECTOR       (RM_MCUBOOT_PORT_CFG_PARTITION_SIZE)
#elif (MCUBOOT_IMAGE_NUMBER == 2)
 #define RM_MCUBOOT_LARGEST_SECTOR       (RM_MCUBOOT_PORT_CFG_S_PARTITION_SIZE &gt; \
                                          RM_MCUBOOT_PORT_CFG_NS_PARTITION_SIZE ? \
                                          RM_MCUBOOT_PORT_CFG_S_PARTITION_SIZE : \
                                          RM_MCUBOOT_PORT_CFG_NS_PARTITION_SIZE)
#else                                  /* MCUBOOT_IMAGE_NUMBER &gt; 2 */
 #error "Only MCUBOOT_IMAGE_NUMBER 1 and 2 are supported!"
#endif /* MCUBOOT_IMAGE_NUMBER */

/* Maximum number of image sectors supported by the bootloader. */
#define MCUBOOT_MAX_IMG_SECTORS    ((RM_MCUBOOT_LARGEST_SECTOR) / \
                                       FLASH_AREA_IMAGE_SECTOR_SIZE)

#ifdef __cplusplus
}
#endif
        </content>
    </config>
    <config id="config.middleware.mcuboot_logging" path="mcu-tools/include/mcuboot_config/mcuboot_logging.h" version="0">
        <property default="config.middleware.mcuboot.mcuboot_logging.off" display="Debugging|Log Level" id="config.middleware.mcuboot.mcuboot_logging" description="Configure log level.">
            <option display="Off" id="config.middleware.mcuboot.mcuboot_logging.off" value=""/>
            <option display="Error" id="config.middleware.mcuboot.mcuboot_logging.error" value="#define MCUBOOT_LOG_LEVEL       MCUBOOT_LOG_LEVEL_ERROR"/>
            <option display="Warning" id="config.middleware.mcuboot.mcuboot_logging.warning" value="#define MCUBOOT_LOG_LEVEL       MCUBOOT_LOG_LEVEL_WARNING"/>
            <option display="Info" id="config.middleware.mcuboot.mcuboot_logging.info" value="#define MCUBOOT_LOG_LEVEL       MCUBOOT_LOG_LEVEL_INFO"/>
            <option display="Debug" id="config.middleware.mcuboot.mcuboot_logging.debug" value="#define MCUBOOT_LOG_LEVEL       MCUBOOT_LOG_LEVEL_DEBUG"/>
        </property>
        <content>
#ifndef __MCUBOOT_LOGGING_H__
#define __MCUBOOT_LOGGING_H__

#ifdef __cplusplus
extern "C" {
#endif

#include &lt;mcuboot_config/mcuboot_config.h&gt;

#define MCUBOOT_LOG_LEVEL_OFF        0
#define MCUBOOT_LOG_LEVEL_ERROR      1
#define MCUBOOT_LOG_LEVEL_WARNING    2
#define MCUBOOT_LOG_LEVEL_INFO       3
#define MCUBOOT_LOG_LEVEL_DEBUG      4

${config.middleware.mcuboot.mcuboot_logging}

/*
 * The compiled log level determines the maximum level that can be
 * printed.
 */
#ifndef MCUBOOT_LOG_LEVEL
 #define MCUBOOT_LOG_LEVEL           MCUBOOT_LOG_LEVEL_OFF
#else
 #include &lt;stdio.h&gt;
#endif

#define MCUBOOT_LOG_MODULE_DECLARE(domain)  /* ignore */
#define MCUBOOT_LOG_MODULE_REGISTER(domain) /* ignore */

#ifndef MCUBOOT_LOG_ERR
 #if MCUBOOT_LOG_LEVEL >= MCUBOOT_LOG_LEVEL_ERROR
  #define MCUBOOT_LOG_ERR(_fmt, ...)           printf("[ERR] " _fmt "\n", ## __VA_ARGS__)
 #else
  #define MCUBOOT_LOG_ERR(...)                 IGNORE(__VA_ARGS__)
 #endif
#endif

#ifndef MCUBOOT_LOG_WRN
 #if MCUBOOT_LOG_LEVEL >= MCUBOOT_LOG_LEVEL_WARNING
  #define MCUBOOT_LOG_WRN(_fmt, ...)    printf("[WRN] " _fmt "\n", ## __VA_ARGS__)
 #else
  #define MCUBOOT_LOG_WRN(...)          IGNORE(__VA_ARGS__)
 #endif
#endif

#ifndef MCUBOOT_LOG_INF
 #if MCUBOOT_LOG_LEVEL >= MCUBOOT_LOG_LEVEL_INFO
  #define MCUBOOT_LOG_INF(_fmt, ...)    printf("[INF] " _fmt "\n", ## __VA_ARGS__)
 #else
  #define MCUBOOT_LOG_INF(...)          IGNORE(__VA_ARGS__)
 #endif
#endif

#ifndef MCUBOOT_LOG_DBG
 #if MCUBOOT_LOG_LEVEL >= MCUBOOT_LOG_LEVEL_DEBUG
  #define MCUBOOT_LOG_DBG(_fmt, ...)    printf("[DBG] " _fmt "\n", ## __VA_ARGS__)
 #else
  #define MCUBOOT_LOG_DBG(...)          IGNORE(__VA_ARGS__)
 #endif
#endif

#ifdef __cplusplus
}
#endif

#endif                                 /* __MCUBOOT_LOGGING_H__ */
        </content>
    </config>
    <config id="config.middleware.mcuboot_sysflash" path="mcu-tools/include/sysflash/sysflash.h" version="0">
        <content>

#ifndef __SYSFLASH_H__
#define __SYSFLASH_H__

#include "mcuboot_config/mcuboot_config.h"

#ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_OSPI_B
#include "mcuboot_config/mcuboot_ospi_b_config.h"
#endif

#include "bsp_api.h"

/* Common macro for FSP header files. There is also a corresponding FSP_FOOTER macro at the end of this file. */
FSP_HEADER

#define FLASH_DEVICE_INTERNAL_FLASH    (0x7F)
#define FLASH_DEVICE_EXTERNAL_FLASH    (0x80)

#define FLASH_AREA_BOOTLOADER          0
#define FLASH_AREA_IMAGE_0             1
#define FLASH_AREA_IMAGE_1             2
#define FLASH_AREA_IMAGE_SCRATCH       3
#define FLASH_AREA_IMAGE_2             5
#define FLASH_AREA_IMAGE_3             6

#if (MCUBOOT_IMAGE_NUMBER == 1)
 #define FLASH_AREA_IMAGE_PRIMARY(x)      (((x) == 0) ?         \
                                           FLASH_AREA_IMAGE_0 : \
                                           FLASH_AREA_IMAGE_0)
 #define FLASH_AREA_IMAGE_SECONDARY(x)    (((x) == 0) ?         \
                                           FLASH_AREA_IMAGE_1 : \
                                           FLASH_AREA_IMAGE_1)

#elif (MCUBOOT_IMAGE_NUMBER == 2)

 #define FLASH_AREA_IMAGE_PRIMARY(x)      (((x) == 0) ?         \
                                           FLASH_AREA_IMAGE_0 : \
                                           ((x) == 1) ?         \
                                           FLASH_AREA_IMAGE_1 : \
                                           255)
 #define FLASH_AREA_IMAGE_SECONDARY(x)    (((x) == 0) ?         \
                                           FLASH_AREA_IMAGE_2 : \
                                           ((x) == 1) ?         \
                                           FLASH_AREA_IMAGE_3 : \
                                           255)

#else
 #warning "Image slot and flash area mapping is not defined"
#endif

#define FLASH_AREA_MCUBOOT_OFFSET     BSP_FEATURE_FLASH_CODE_FLASH_START

/* Define an offset if placing image at an address other than the start of the XSPI region. */
#ifndef XSPI_AREA_MCUBOOT_OFFSET
 #define XSPI_AREA_MCUBOOT_OFFSET      (0x0)
#endif

#if BSP_FEATURE_FLASH_HP_SUPPORTS_DUAL_BANK
 #define RM_MCUBOOT_DUAL_BANK_ENABLED    (!(0x7U &amp; (BSP_CFG_ROM_REG_DUALSEL)))
#elif BSP_FEATURE_FLASH_LP_SUPPORTS_DUAL_BANK
 #define RM_MCUBOOT_DUAL_BANK_ENABLED    MCUBOOT_DUALBANK_FLASH_LP
#endif

#if (MCUBOOT_IMAGE_NUMBER == 1)

/* Secure + Non-Secure image primary slot */
 #ifndef FLASH_AREA_0_ID
  #define FLASH_AREA_0_ID               (FLASH_AREA_IMAGE_0)
 #endif
 #ifndef FLASH_AREA_0_OFFSET
  #define FLASH_AREA_0_OFFSET           (FLASH_AREA_MCUBOOT_OFFSET + RM_MCUBOOT_PORT_CFG_MCUBOOT_SIZE)
 #endif
 #ifndef FLASH_AREA_0_SIZE
  #define FLASH_AREA_0_SIZE             (RM_MCUBOOT_PORT_CFG_PARTITION_SIZE)
 #endif

/* Secure + Non-secure secondary slot */
 #ifndef FLASH_AREA_2_ID
  #define FLASH_AREA_2_ID               (FLASH_AREA_IMAGE_1)
 #endif
 #ifndef FLASH_AREA_2_OFFSET
  #ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_QSPI
   #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_QSPI_DEVICE_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
  #elif defined(RM_MCUBOOT_PORT_CFG_SECONDARY_USE_OSPI_B)
   #if (RM_MCUBOOT_PORT_CFG_OSPI_B_CHANNEL == 1)
    #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_OSPI_B_DEVICE_1_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
   #elif (RM_MCUBOOT_PORT_CFG_OSPI_B_CHANNEL == 0)
    #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_OSPI_B_DEVICE_0_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
   #endif
  #elif RM_MCUBOOT_DUAL_BANK_ENABLED
   #if BSP_FEATURE_FLASH_HP_VERSION > 0
    #define FLASH_AREA_2_OFFSET          (BSP_FEATURE_FLASH_HP_CF_DUAL_BANK_START + \
                                        RM_MCUBOOT_PORT_CFG_MCUBOOT_SIZE)
   #else
    #define FLASH_AREA_2_OFFSET          (BSP_FEATURE_FLASH_LP_CF_DUAL_BANK_START + \
                                        RM_MCUBOOT_PORT_CFG_MCUBOOT_SIZE)
   #endif
  #else
   #define FLASH_AREA_2_OFFSET           (FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE)
  #endif
 #endif
 #ifndef FLASH_AREA_2_SIZE
  #define FLASH_AREA_2_SIZE             (RM_MCUBOOT_PORT_CFG_PARTITION_SIZE)
 #endif

/* Swap space.  */
 #ifndef FLASH_AREA_SCRATCH_ID
  #define FLASH_AREA_SCRATCH_ID         (FLASH_AREA_IMAGE_SCRATCH)
 #endif
 #ifndef FLASH_AREA_SCRATCH_OFFSET
  #ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_XSPI
   #define FLASH_AREA_SCRATCH_OFFSET     (FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE)
  #else
   #define FLASH_AREA_SCRATCH_OFFSET     (FLASH_AREA_2_OFFSET + FLASH_AREA_2_SIZE)
  #endif
 #endif
 #ifndef FLASH_AREA_SCRATCH_SIZE
  #define FLASH_AREA_SCRATCH_SIZE       (RM_MCUBOOT_PORT_CFG_SCRATCH_SIZE)
 #endif

#elif (MCUBOOT_IMAGE_NUMBER == 2)

/* Swap space.  */
 #ifndef FLASH_AREA_SCRATCH_ID
  #define FLASH_AREA_SCRATCH_ID         (FLASH_AREA_IMAGE_SCRATCH)
 #endif
 #ifndef FLASH_AREA_SCRATCH_OFFSET
  #define FLASH_AREA_SCRATCH_OFFSET     (FLASH_AREA_MCUBOOT_OFFSET + RM_MCUBOOT_PORT_CFG_MCUBOOT_SIZE)
 #endif
 #ifndef FLASH_AREA_SCRATCH_SIZE
  #define FLASH_AREA_SCRATCH_SIZE       (RM_MCUBOOT_PORT_CFG_SCRATCH_SIZE)
 #endif

/* Secure image secondary slot */
 #ifndef FLASH_AREA_2_ID
  #define FLASH_AREA_2_ID               (FLASH_AREA_IMAGE_2)
 #endif
 #ifndef FLASH_AREA_2_OFFSET
  #ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_QSPI
   #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_QSPI_DEVICE_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
  #elif defined(RM_MCUBOOT_PORT_CFG_SECONDARY_USE_OSPI_B)
   #if (RM_MCUBOOT_PORT_CFG_OSPI_B_CHANNEL == 1)
    #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_OSPI_B_DEVICE_1_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
   #elif (RM_MCUBOOT_PORT_CFG_OSPI_B_CHANNEL == 0)
    #define FLASH_AREA_2_OFFSET           (BSP_FEATURE_OSPI_B_DEVICE_0_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET)
   #endif
  #else
   #define FLASH_AREA_2_OFFSET           (FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE)
  #endif
 #endif
 #ifndef FLASH_AREA_2_SIZE
  #define FLASH_AREA_2_SIZE             (RM_MCUBOOT_PORT_CFG_S_PARTITION_SIZE)
 #endif

/* Secure image primary slot */
 #ifndef FLASH_AREA_0_ID
  #define FLASH_AREA_0_ID               (FLASH_AREA_IMAGE_0)
 #endif
 #ifndef FLASH_AREA_0_OFFSET
  #ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_QSPI
   #define FLASH_AREA_0_OFFSET           (FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE)
  #else
   #define FLASH_AREA_0_OFFSET           (FLASH_AREA_2_OFFSET + FLASH_AREA_2_SIZE)
  #endif
 #endif
 #ifndef FLASH_AREA_0_SIZE
  #define FLASH_AREA_0_SIZE             (RM_MCUBOOT_PORT_CFG_S_PARTITION_SIZE)
 #endif

/* Non-Secure image primary slot */
 #ifndef FLASH_AREA_1_ID
  #define FLASH_AREA_1_ID               (FLASH_AREA_IMAGE_1)
 #endif
 #ifndef FLASH_AREA_1_OFFSET
  #define FLASH_AREA_1_OFFSET           (FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE) + BSP_FEATURE_TZ_NS_OFFSET
 #endif
 #ifndef FLASH_AREA_1_SIZE
  #define FLASH_AREA_1_SIZE             (RM_MCUBOOT_PORT_CFG_NS_PARTITION_SIZE)
 #endif

/* Non-Secure image secondary slot */
 #ifndef FLASH_AREA_3_ID
  #define FLASH_AREA_3_ID               (FLASH_AREA_IMAGE_3)
 #endif
 #ifndef FLASH_AREA_3_OFFSET
   #ifdef RM_MCUBOOT_PORT_CFG_SECONDARY_USE_XSPI
   #define FLASH_AREA_3_OFFSET           (BSP_FEATURE_QSPI_DEVICE_START_ADDRESS + XSPI_AREA_MCUBOOT_OFFSET + FLASH_AREA_2_SIZE)
   #else
   #define FLASH_AREA_3_OFFSET           (FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE)
  #endif
 #endif
 #ifndef FLASH_AREA_3_SIZE
  #define FLASH_AREA_3_SIZE             (RM_MCUBOOT_PORT_CFG_NS_PARTITION_SIZE)
 #endif
#else                                  /* MCUBOOT_IMAGE_NUMBER > 2 */
 #error "Only MCUBOOT_IMAGE_NUMBER 1 and 2 are supported!"
#endif /* MCUBOOT_IMAGE_NUMBER */

/* Common macro for FSP header files. There is also a corresponding FSP_HEADER macro at the top of this file. */
FSP_FOOTER

#endif /* __SYSFLASH_H__ */

        </content>
    </config>
    <module config="config.middleware.mcuboot" display="Bootloader|MCUboot" id="module.middleware.mcuboot" version="1" url="https://github.com/mcu-tools/mcuboot">
        <constraint display="Only one MCUboot instance can be used at a time.">
          "${interface.middleware.mcuboot}" === "1"
        </constraint>
        <constraint display="Attempting to use more internal flash than exists on the MCU.">
          !testExists("${config.bsp.rom_size_bytes_hidden}") ||
          ((${config.middleware.mcuboot.flash_area_bootloader_size} +
           (2 * ${config.middleware.mcuboot.flash_s_partition_size}) +
           ${config.middleware.mcuboot.scratch_partition_size} +
           (2 * ${config.middleware.mcuboot.flash_ns_partition_size})) &lt;= parseInt("${config.bsp.rom_size_bytes_hidden}")) ||
          ((testExists("${interface.driver.rm_mcuboot_external_memory_qspi}")) &amp;&amp;
           ((${config.middleware.mcuboot.flash_area_bootloader_size} +
           (${config.middleware.mcuboot.flash_s_partition_size}) +
           ${config.middleware.mcuboot.scratch_partition_size} +
           (${config.middleware.mcuboot.flash_ns_partition_size})) &lt;= parseInt("${config.bsp.rom_size_bytes_hidden}")))
        </constraint>
        <!-- Trailer size (5 * BOOT_MAX_ALIGN) + (BOOT_MAX_IMG_SECTORS * min-write-size * 3) -->
        <constraint display="If Non-Secure Callable space is allocated in a project with 2 separately updateable images and swap mode is used, it must be large enough to hold the MCUboot trailer. For this MCU, the MCUboot trailer size is (128 * (5 + (3 * BOOT_MAX_IMG_SECTORS))).">
          ("${config.middleware.mcuboot.image_number}" == "config.middleware.mcuboot.image_number.1") ||
          ("${config.middleware.mcuboot.alignment}" != "enum.mcu.flash.min_write_size.128") ||
          ("${config.middleware.mcuboot.upgrade_mode}" != "config.middleware.mcuboot.upgrade_mode.swap") ||
          (0 == ${config.middleware.mcuboot.flash_nsc_partition_size}) ||
          (${config.middleware.mcuboot.flash_nsc_partition_size} &gt;=
          (128 * (5 + (3 * (${config.middleware.mcuboot.flash_s_partition_size} > ${config.middleware.mcuboot.flash_ns_partition_size} ? ${config.middleware.mcuboot.flash_s_partition_size} : ${config.middleware.mcuboot.flash_ns_partition_size}) / 0x8000))))
        </constraint>
        <constraint display="The Flash Area Sizes must be multiples of the minimum erase size (0x8000).">
          ("${config.middleware.mcuboot.sector_size}" != "enum.mcu.flash.min_erase_size.8000") ||
          ((${config.middleware.mcuboot.flash_area_bootloader_size} % 0x8000 === 0) &amp;&amp;
          (${config.middleware.mcuboot.flash_s_partition_size} % 0x8000 === 0) &amp;&amp;
          (${config.middleware.mcuboot.scratch_partition_size} % 0x8000 === 0) &amp;&amp;
          (${config.middleware.mcuboot.flash_ns_partition_size} % 0x8000 === 0))
        </constraint>
        <constraint display="The Flash Area Sizes must be multiples of the minimum erase size (0x800).">
          ("${config.middleware.mcuboot.sector_size}" != "enum.mcu.flash.min_erase_size.800") ||
          ((${config.middleware.mcuboot.flash_area_bootloader_size} % 0x800 === 0) &amp;&amp;
          (${config.middleware.mcuboot.flash_s_partition_size} % 0x800 === 0) &amp;&amp;
          (${config.middleware.mcuboot.scratch_partition_size} % 0x800 === 0) &amp;&amp;
          (${config.middleware.mcuboot.flash_ns_partition_size} % 0x800 === 0))
        </constraint>
        <constraint display="Value must be an integer multiple of 0x200 (alignment required by VTOR).">
          testInteger("${config.middleware.mcuboot.flash_area_bootloader_header_size}")  &amp;&amp; (${config.middleware.mcuboot.flash_area_bootloader_header_size} &gt; 0) &amp;&amp; (${config.middleware.mcuboot.flash_area_bootloader_header_size} % 0x200 == 0)
        </constraint>
        <constraint display="Value must be an integer multiple of 0x200 (alignment required by VTOR).">
          testInteger("${config.middleware.mcuboot.flash_area_bootloader_header_size_2}")  &amp;&amp; (${config.middleware.mcuboot.flash_area_bootloader_header_size_2} &gt; 0) &amp;&amp; (${config.middleware.mcuboot.flash_area_bootloader_header_size_2} % 0x200 == 0)
        </constraint>
        <constraint display="The Scratch Flash Area is required when Upgrade Mode is set to Swap.">
          (("${config.middleware.mcuboot.upgrade_mode}" != "config.middleware.mcuboot.upgrade_mode.swap") ||
          (${config.middleware.mcuboot.scratch_partition_size} > 0))
        </constraint>
        <constraint display="Set the Scratch Flash Area Size (bytes) to 0 if Upgrade Mode is not Swap.">
          (("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.swap") ||
          (${config.middleware.mcuboot.scratch_partition_size} == 0))
        </constraint>
        <constraint display="The TrustZone memory regions must be non-zero when the Image Number is 2.">
          ("${config.middleware.mcuboot.image_number}" == "config.middleware.mcuboot.image_number.1") ||
          ((${config.middleware.mcuboot.flash_ns_partition_size} > 0) &amp;&amp;
          (${config.middleware.mcuboot.flash_nsc_partition_size} > 0) &amp;&amp;
          (${config.middleware.mcuboot.ram_ns_partition_size} > 0))
        </constraint>
        <constraint display="Downgrade Prevention is only supported in Overwrite Only and Overwrite Only Fast modes.">
          (("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.overwrite_only") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.overwrite_only_fast") ||
          ("${config.middleware.mcuboot.downgrade_prevention}" == "config.middleware.mcuboot.downgrade_prevention.disabled"))
        </constraint>
        <constraint display="Signing Options must be set to None or ECDSA P-256 if TinyCrypt is used.">
          (("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.none") ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.ecdsap256") ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.ecdsap384") ||
           (testExists ("${interface.driver.mcuboot_crypto_sce9_protected}")) ||
           (testExists ("${interface.driver.psa_crypto}")))
        </constraint>
        <constraint display="Encryption Scheme must be set to Disabled or ECIES-P256 if TinyCrypt is used.">
          (("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.none") ||
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec256") ||
           (testExists ("${interface.driver.mcuboot_crypto_sce9_protected}")) ||
           (testExists ("${interface.driver.psa_crypto}")))
        </constraint>
        <constraint display="Signing and encryption must use the same type of key.">
          (((("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.ecdsap256") ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.none")) &amp;&amp;
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec256")) ||
           ((("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.ecdsap384") ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.none")) &amp;&amp;
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec384")) ||
           (((("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.rsa2048") ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.rsa3072")) ||
           ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.none")) &amp;&amp;
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.rsa")) ||
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.none"))
        </constraint>
        <constraint display="MCUboot Custom Crypto (Protected Mode) cannot be used if Encryption is enabled.">
            ((!testExists ("${interface.driver.mcuboot_crypto_sce9_protected}")) &amp;&amp;
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec256")) ||
            ((!testExists ("${interface.driver.mcuboot_crypto_sce9_protected}")) &amp;&amp;
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.rsa")) ||
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.none")
        </constraint>
        <constraint display="MCUboot Direct XIP cannot be used if Encryption is enabled.">
            (("${config.middleware.mcuboot.upgrade_mode}" != "config.middleware.mcuboot.upgrade_mode.direct_xip") &amp;&amp;
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec256")) ||
            (("${config.middleware.mcuboot.upgrade_mode}" != "config.middleware.mcuboot.upgrade_mode.direct_xip") &amp;&amp;
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.rsa")) ||
            ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.none")
        </constraint>

        <constraint display="MBEDTLS_ECDH_C must be defined under MbedTLS (Crypto Only)|Common|Public Key Cryptography (PKC)|ECC|MBEDTLS_ECDH_C.">
           (!testExists ("${interface.driver.psa_crypto}")) ||
           (("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.rsa") ||
           ("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.none") ||
           (("${config.middleware.mcuboot.encryption_key}" == "config.middleware.mcuboot.encryption_key.ec256") &amp;&amp;
           ("${config.driver.psa_crypto.mbedtls_ecdh_c}" == "config.driver.psa_crypto.mbedtls_ecdh_c.enabled")))
        </constraint>
        <constraint display="ASN.1 parser is required for ECDSA if TinyCrypt or Custom Crypto (Protected Mode) is used as crypto stack.">
          (testExists ("${interface.driver.psa_crypto}"))
          || ((testExists ("${interface.middleware.mcuboot.asn1_parser}")) &amp;&amp;testExists ("${interface.driver.mcuboot_crypto_sce9_protected}"))
          || ((testExists ("${interface.middleware.mcuboot.asn1_parser}")) &amp;&amp;  (testExists ("${interface.driver.tinycrypt}")))
          || ((testExists ("${interface.middleware.mcuboot.asn1_parser}")) &amp;&amp;  (testExists ("${interface.driver.mcuboot_tinycrypt}")))
          || ("${config.middleware.mcuboot.signature}" == "config.middleware.mcuboot.signature.none")
        </constraint>
        <constraint display="ASN.1 parser must not be added if MbedTLS is used as crypto stack">
          ((testExists ("${interface.driver.psa_crypto}")) &amp;&amp; (!testExists ("${interface.middleware.mcuboot.asn1_parser}")))
          || (testExists ("${interface.driver.mcuboot_crypto_sce9_protected}")) || (testExists ("${interface.driver.tinycrypt}"))
		  || (testExists ("${interface.driver.mcuboot_tinycrypt}"))
        </constraint>
        <constraint display="Only one of MbedTLS or TinyCrypt or Custom Crypto (Protected Mode) crypto stack can be used.">
          (!(testExists ("${interface.driver.psa_crypto}") &amp;&amp; (testExists ("${interface.driver.tinycrypt}"))) ||
          (testExists ("${interface.driver.psa_crypto}") &amp;&amp; (testExists ("${interface.driver.sce_on_sce_protected}"))) ||
          (testExists ("${interface.driver.tinycrypt}") &amp;&amp; (testExists ("${interface.driver.sce_on_sce_protected}"))))
        </constraint>

        <!-- XIP mode cannot support TrustZone projects. -->
        <constraint display="Direct XIP Upgrade Mode not supported for TrustZone projects.">
          ("${config.middleware.mcuboot.image_number}" == "config.middleware.mcuboot.image_number.1") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.swap") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.overwrite_only") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.overwrite_only_fast")
        </constraint>

        <!-- Dual Bank requires Direct XIP mode  -->
        <constraint display="Dual Bank operation requires Upgrade Mode to be set to Direct XIP.">
          (!(testExists("${config.bsp.fsp.dual_bank}"))) ||
          ("${config.bsp.fsp.dual_bank}" == "config.bsp.fsp.dual_bank.disabled") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.direct_xip")
        </constraint>

        <constraint display="Dual Bank Mode (Flash LP) is only supported in Direct XIP mode.">
          (("${config.middleware.mcuboot.flash_lp.dual_bank}" == "enum.mcu.flash_lp.dual_bank.disabled") ||
          ("${config.middleware.mcuboot.upgrade_mode}" == "config.middleware.mcuboot.upgrade_mode.direct_xip"))
        </constraint>

        <requires id="module.middleware.mcuboot.requires.rm_mcuboot_port" interface="interface.middleware.mcuboot_port" visible="true" display="Requires MCUboot Port for RA" />
        <requires id="module.middleware.mcuboot.requires.mcuboot_logging" interface="interface.middleware.mcuboot_logging" visible="true" display="[Optional] Add Logging Support" find="true" optional="true"/>
        <requires id="module.middleware.mcuboot.requires.mcuboot_keys" interface="interface.middleware.mcuboot.example_keys" visible="true" display="[Optional] Add Example Keys" find="false"  optional="true"/>
        <requires id="module.middleware.mcuboot.requires.mcuboot_asn1_parser" interface="interface.middleware.mcuboot.asn1_parser" visible="true" display="Add ASN.1 parser if using TinyCrypt or Custom Crypto (Protected Mode)" find="false" />
        <provides interface="interface.middleware.mcuboot" />
        <!-- inform the tooling that this is a bootloader project via the system-level _bootloader interface -->
        <provides interface="_bootloader" />
        <!-- expose a config property value to the linker script -->
        <memory accumulator="FLASH_BOOTLOADER_LENGTH">
            ${config.middleware.mcuboot.flash_area_bootloader_size}
        </memory>
        <memory accumulator="FLASH_BOOTLOADER_HEADER_LENGTH">
            ${config.middleware.mcuboot.flash_area_bootloader_header_size}
        </memory>
        <memory accumulator="FLASH_BOOTLOADER_HEADER_LENGTH_2">
            ${config.middleware.mcuboot.flash_area_bootloader_header_size_2}
        </memory>
        <memory accumulator="FLASH_BOOTLOADER_SCRATCH_LENGTH">
            ${config.middleware.mcuboot.scratch_partition_size}
        </memory>
        <memory accumulator="FLASH_APPLICATION_S_LENGTH">
            ${config.middleware.mcuboot.flash_s_partition_size}
        </memory>
        <memory accumulator="FLASH_APPLICATION_NSC_LENGTH">
            ${config.middleware.mcuboot.flash_nsc_partition_size}
        </memory>
        <memory accumulator="FLASH_APPLICATION_NS_LENGTH">
            ${config.middleware.mcuboot.flash_ns_partition_size}
        </memory>
        <memory accumulator="RAM_APPLICATION_NSC_LENGTH">
            ${config.middleware.mcuboot.ram_nsc_partition_size}
        </memory>
        <memory accumulator="RAM_APPLICATION_NS_LENGTH">
            ${config.middleware.mcuboot.ram_ns_partition_size}
        </memory>
        <memory accumulator="FLASH_APPLICATION_IMAGE_NUMBER">
            ${config.middleware.mcuboot.image_number}
        </memory>
        <image path="${BuildArtifactFileBaseName}.bin.signed">
            <![CDATA[eval('' +
  '/* INPUTS */' +
  '    var alignment = ${config.middleware.mcuboot.alignment};' +
  '    var s_image = ${config.middleware.mcuboot.flash_s_partition_size};' +
  '    var ns_image = ${config.middleware.mcuboot.flash_ns_partition_size};' +
  '    var scratch_size = ${config.middleware.mcuboot.scratch_partition_size};' +
  '    var bootloader_size = ${config.middleware.mcuboot.flash_area_bootloader_size};' +
  '    var flash_erase_size_bytes = ${config.middleware.mcuboot.sector_size};' +
  '    var header_size = ${config.middleware.mcuboot.flash_area_bootloader_header_size};' +
  '    var header_size_2 = ${config.middleware.mcuboot.flash_area_bootloader_header_size_2};' +
  '    var image_number = ${config.middleware.mcuboot.image_number};' +
  '    var upgrade_mode = "${config.middleware.mcuboot.upgrade_mode}";' +
  '    var extra_options = "${config.middleware.mcuboot.sign_custom}";' +
  '    var extra_options_2 = "${config.middleware.mcuboot.sign_custom_image_2}";' +
  '    var boot_record = "${config.middleware.mcuboot.boot_record}";' +
  '    var boot_record_image_2 = "${config.middleware.mcuboot.boot_record_image_2}";' +
  '    var overwrite_only = "";' +
  '    var key_option = "";' +
  '    var sign_ns = "";' +
  '    var python_command = "${config.middleware.mcuboot.python_command}";' +
  '' +
  '    if ((upgrade_mode.indexOf("MCUBOOT_OVERWRITE_ONLY")) !== -1)' +
  '    {' +
  '        overwrite_only = " --overwrite-only";' +
  '    }' +
  '' +
  '    var boot_record_arg = "";' +
  '    if (boot_record.length > 0)' +
  '    {' +
  '        boot_record_arg = " --boot-record " + boot_record;' +
  '    }' +
  '    var boot_record_arg_2 = "";' +
  '    if (boot_record_image_2.length > 0)' +
  '    {' +
  '        boot_record_arg_2 = " --boot-record " + boot_record_image_2;' +
  '    }' +
  '' +
  '    max_sectors = s_image / flash_erase_size_bytes;' +
  '    s_slot = bootloader_size;' +
  '    s_slot_upgrade = bootloader_size + s_image;' +
  '    if (image_number > 1)' +
  '    {' +
  '        s_slot = bootloader_size + scratch_size + s_image;' +
  '        s_slot_upgrade = bootloader_size + scratch_size;' +
  '        ns_slot = s_slot + s_image;' +
  '        ns_slot_upgrade = ns_slot + ns_image;' +
  '        if (ns_image > s_image)' +
  '        {' +
  '            max_sectors = ns_image / flash_erase_size_bytes;' +
  '        }' +
  '        else' +
  '        {' +
  '            max_sectors = s_image / flash_erase_size_bytes;' +
  '        }' +
  '    }' +
  '' +
  '    python_command + " ${workspace_loc:${_project.name}}/ra/fsp/src/rm_mcuboot_port/rm_mcuboot_port_sign.py sign" + " --header-size 0x" + header_size.toString(16) + " --align " + alignment.toString() + " --max-align " + alignment.toString() + " --slot-size 0x" + s_image.toString(16) + " --max-sectors " + max_sectors.toString() + overwrite_only + " " + extra_options + boot_record_arg + " --pad-header ${BuildArtifactFileName} ${BuildArtifactFileBaseName}.bin.signed"'
  )]]>
        </image>
        <image path="${BuildArtifactFileBaseName}.bin.signed" security="n">
            <![CDATA[eval('' +
  '/* INPUTS */' +
  '    var alignment = ${config.middleware.mcuboot.alignment};' +
  '    var s_image = ${config.middleware.mcuboot.flash_s_partition_size};' +
  '    var ns_image = ${config.middleware.mcuboot.flash_ns_partition_size};' +
  '    var scratch_size = ${config.middleware.mcuboot.scratch_partition_size};' +
  '    var bootloader_size = ${config.middleware.mcuboot.flash_area_bootloader_size};' +
  '    var flash_erase_size_bytes = ${config.middleware.mcuboot.sector_size};' +
  '    var header_size = ${config.middleware.mcuboot.flash_area_bootloader_header_size};' +
  '    var header_size_2 = ${config.middleware.mcuboot.flash_area_bootloader_header_size_2};' +
  '    var image_number = ${config.middleware.mcuboot.image_number};' +
  '    var upgrade_mode = "${config.middleware.mcuboot.upgrade_mode}";' +
  '    var extra_options = "${config.middleware.mcuboot.sign_custom}";' +
  '    var extra_options_2 = "${config.middleware.mcuboot.sign_custom_image_2}";' +
  '    var boot_record = "${config.middleware.mcuboot.boot_record}";' +
  '    var boot_record_image_2 = "${config.middleware.mcuboot.boot_record_image_2}";' +
  '    var overwrite_only = "";' +
  '    var key_option = "";' +
  '    var sign_ns = "";' +
  '    var python_command = "${config.middleware.mcuboot.python_command}";' +
  '' +
  '    if ((upgrade_mode.indexOf("MCUBOOT_OVERWRITE_ONLY")) !== -1)' +
  '    {' +
  '        overwrite_only = " --overwrite-only";' +
  '    }' +
  '' +
  '    var boot_record_arg = "";' +
  '    if (boot_record.length > 0)' +
  '    {' +
  '        boot_record_arg = " --boot-record " + boot_record;' +
  '    }' +
  '    var boot_record_arg_2 = "";' +
  '    if (boot_record_image_2.length > 0)' +
  '    {' +
  '        boot_record_arg_2 = " --boot-record " + boot_record_image_2;' +
  '    }' +
  '' +
  '    max_sectors = s_image / flash_erase_size_bytes;' +
  '    s_slot = bootloader_size;' +
  '    s_slot_upgrade = bootloader_size + s_image;' +
  '    if (image_number > 1)' +
  '    {' +
  '        s_slot = bootloader_size + scratch_size + s_image;' +
  '        s_slot_upgrade = bootloader_size + scratch_size;' +
  '        ns_slot = s_slot + s_image;' +
  '        ns_slot_upgrade = ns_slot + ns_image;' +
  '        if (ns_image > s_image)' +
  '        {' +
  '            max_sectors = ns_image / flash_erase_size_bytes;' +
  '        }' +
  '        else' +
  '        {' +
  '            max_sectors = s_image / flash_erase_size_bytes;' +
  '        }' +
  '    }' +
  '    python_command + " ${workspace_loc:${_project.name}}/ra/fsp/src/rm_mcuboot_port/rm_mcuboot_port_sign.py sign" + " --header-size 0x" + header_size_2.toString(16) + " --align " + alignment.toString() + " --max-align " + alignment.toString() + " --slot-size 0x" + ns_image.toString(16) + " --max-sectors " + max_sectors.toString() + overwrite_only + " " + extra_options_2 + boot_record_arg_2 + " --pad-header ${BuildArtifactFileName} ${BuildArtifactFileBaseName}.bin.signed"'
  )]]>
        </image>
        <header>
void mcuboot_quick_setup();
        </header>
        <includes>
#include "rm_mcuboot_port.h"
#if defined(MCUBOOT_USE_MBED_TLS)
#include "mbedtls/platform.h"
#endif
        </includes>
    </module>
    <module config="config.middleware.mcuboot_logging" display="Bootloader|MCUboot logging" id="module.middleware.mcuboot_logging" version="1" visible="false" url="https://github.com/mcu-tools/mcuboot">
        <provides interface="interface.middleware.mcuboot_logging" />
    </module>
    <module config="config.middleware.mcuboot_sysflash" display="Bootloader|MCUboot sysflash" id="module.middleware.mcuboot_sysflash" version="1" visible="false" url="https://github.com/mcu-tools/mcuboot">
        <provides interface="interface.middleware.mcuboot_sysflash" />
    </module>
    <developerSupport>
        <api version="1">
            <platform id="fsp" max="" min="1.1.0"/>
            <moduleRef id="module.middleware.mcuboot"/>
            <description><![CDATA[<form><p><span color="header" font="header">Overview</span></p><p>Provides snippets of code to create an MCUboot image and sign the application images.</p></form>]]></description>
            <function display="Quick Setup" id="mcuboot_setup">
                <description><![CDATA[<form><p>Template to start an MCUboot application.</p></form>]]></description>
            </function>
        </api>
        <template category="function_call" display="Call Quick Setup" id="module.middleware.mcuboot.quick_setup" version="1">
            <platform id="fsp" max="" min="1.1.0"/>
            <moduleRef id="module.middleware.mcuboot">
                <function id="mcuboot_setup"/>
            </moduleRef>
            <content>
/* Quick setup for MCUboot.
 *
 * To update the linker regions of an application to be used with this bootloader, add a the *.bld file created during the
 * build as a File property in e2 studio or RASC under Project > Properties, then C/C++ Build > Build Variables with variable
 * name BootloaderDataFile.
 * If QSPI/OSPI is used, the QSPI/OSPI flash must be initialized in Extended-SPI mode by calling R_QSPI_Open() or R_OSPI_B_Open() before boot_go() is called.
 */
void mcuboot_quick_setup()
{
#ifdef MCUBOOT_USE_MBED_TLS

    /* Initialize mbedtls. */
    mbedtls_platform_context ctx = {0};
    assert(0 == mbedtls_platform_setup(&amp;ctx));
#elif (defined(MCUBOOT_USE_TINYCRYPT) &amp;&amp; defined(RM_MCUBOOT_PORT_USE_TINYCRYPT_ACCELERATION))

    /* Initialize TinyCrypt port. */
    assert(FSP_SUCCESS == RM_TINCYRYPT_PORT_Init());
#elif (defined(MCUBOOT_USE_USER_DEFINED_CRYPTO_STACK))

/* Initialize Custom Crypto (Protected Mode) driver. */
    assert(FSP_SUCCESS == R_SCE_Open(&amp;sce_ctrl, &amp;sce_cfg));
#endif

    /* (Optional, not required if --pad is used during signing) To check for updates, call boot_set_pending. */
    bool update = 0;
    if (update)
    {
        boot_set_pending(0);
    }

    /* Verify the boot image and get its location. */
    struct boot_rsp rsp;
    assert(0 == boot_go(&amp;rsp));

    /* Enter the application. */
    RM_MCUBOOT_PORT_BootApp(&amp;rsp);
}
            </content>
        </template>
    </developerSupport>
</raModuleDescription>